<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Celery 源码解析 - 7 - 游戏不存在</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="shawn" /><meta name="description" content="本章我们从celery的蓝图学习celery的实现细节。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一" /><meta name="keywords" content="game, docker, kubernetes, python, go,  microservice" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://game404.github.io/post/python/celery-7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Celery 源码解析 - 7" />
<meta property="og:description" content="本章我们从celery的蓝图学习celery的实现细节。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://game404.github.io/post/python/celery-7/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-12T22:55:38+08:00" />
<meta property="article:modified_time" content="2021-12-12T22:55:38+08:00" />

<meta itemprop="name" content="Celery 源码解析 - 7">
<meta itemprop="description" content="本章我们从celery的蓝图学习celery的实现细节。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一"><meta itemprop="datePublished" content="2021-12-12T22:55:38+08:00" />
<meta itemprop="dateModified" content="2021-12-12T22:55:38+08:00" />
<meta itemprop="wordCount" content="4166">
<meta itemprop="keywords" content="celery,源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Celery 源码解析 - 7"/>
<meta name="twitter:description" content="本章我们从celery的蓝图学习celery的实现细节。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">游戏不存在</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">游戏不存在</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Celery 源码解析 - 7</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-12 </span>
        <div class="post-category">
            <a href="/categories/python/"> python </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#蓝图设计">蓝图设计</a></li>
    <li><a href="#connection-step实现amqp协议连接">Connection-Step实现AMQP协议连接</a></li>
    <li><a href="#pool-step实现并发模型">Pool-Step实现并发模型</a></li>
    <li><a href="#evloop-step实现事件循环">Evloop-Step实现事件循环</a></li>
    <li><a href="#consumer-blueprint实现任务调度">Consumer-Blueprint实现任务调度</a></li>
    <li><a href="#mingle-step和gossip-step实现worker分布式协作">Mingle-Step和Gossip-Step实现worker分布式协作</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>本章我们从celery的蓝图学习celery的实现细节。</p>
<p>Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一整套操作此系统的工具。Celery 也是一款消息队列工具，可用于处理实时数据以及任务调度。</p>
<p>本文是是celery源码解析的第<strong>七</strong>篇，在前六篇里分别介绍了:</p>
<ol>
<li><a href="https://game404.github.io/post/python/celery-1/">神器 celery 源码解析- vine实现Promise功能</a></li>
<li><a href="https://game404.github.io/post/python/celery-2/">神器 celery 源码解析- py-amqp实现AMQP协议</a></li>
<li><a href="https://game404.github.io/post/python/celery-3/">神器 celery 源码解析- kombu，一个python实现的消息库</a></li>
<li><a href="https://game404.github.io/post/python/celery-4/">神器 celery 源码解析- kombu的企业级算法</a></li>
<li><a href="https://game404.github.io/post/python/celery-5/">神器 celery 源码解析- celery启动流程分析</a></li>
<li><a href="https://game404.github.io/post/python/celery-6/">神器 celery 源码解析- celery启动日志跟踪</a></li>
</ol>
<h2 id="蓝图设计">蓝图设计</h2>
<p>celery的蓝图，官方的解释是 <em>A directed acyclic graph of reusable components</em> ，翻译过来就是 <em>可重用组件的有向无环图</em> 。有WorkController(也叫worker)和Consumer两个蓝图，每个蓝图又由一些step组成，这些step根据依赖关系(requires)组成下面的树结构:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">WorkController(Blueprint)
</span></span><span class="line"><span class="cl">    |-  StateDB
</span></span><span class="line"><span class="cl">    |-  Timer
</span></span><span class="line"><span class="cl">            |- Hub
</span></span><span class="line"><span class="cl">                |- Pool
</span></span><span class="line"><span class="cl">                    |- WorkerComponent(Autoscaler)
</span></span><span class="line"><span class="cl">    |-  Beat
</span></span><span class="line"><span class="cl">    |-  Consumer(Blueprint)
</span></span><span class="line"><span class="cl">            |- Connection
</span></span><span class="line"><span class="cl">                |- Agent
</span></span><span class="line"><span class="cl">                |- Events
</span></span><span class="line"><span class="cl">                    |- Mingle
</span></span><span class="line"><span class="cl">                        |- Gossip
</span></span><span class="line"><span class="cl">                        |- Tasks
</span></span><span class="line"><span class="cl">                            |- Control
</span></span><span class="line"><span class="cl">                    |- Heart
</span></span><span class="line"><span class="cl">        |- Evloop
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中Consumer是WorkController的一个step，这个step又启动了一个Consumer的蓝图，形成一个蓝图嵌蓝图的结构。蓝图这个词，可以理解为celery启动的时候需要一些步骤，这些步骤是有依赖顺序的，同级的步骤构成一个蓝图。</p>
<p>Worker蓝图包括<code>{StateDB, Timer, Hub, Pool, Autoscaler, Beat, Consumer}</code>七个步骤，一般情况下仅仅启动了其中的三个<code>Hub， Pool， Consumer</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[2021-11-24 15:53:12,984: DEBUG/MainProcess] | Worker: Preparing bootsteps.
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:12,988: DEBUG/MainProcess] | Worker: Building graph...
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:12,988: DEBUG/MainProcess] | Worker: New boot order: {StateDB, Timer, Hub, Pool, Autoscaler, Beat, Consumer}
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,062: DEBUG/MainProcess] | Worker: Starting Hub
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,062: DEBUG/MainProcess] ^-- substep ok
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,062: DEBUG/MainProcess] | Worker: Starting Pool
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,410: DEBUG/MainProcess] ^-- substep ok
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,411: DEBUG/MainProcess] | Worker: Starting Consumer
</span></span></code></pre></td></tr></table>
</div>
</div><p>这七个蓝图的顺序和配置的顺序是有差异的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">default_steps = {
</span></span><span class="line"><span class="cl">    &#39;celery.worker.components:Hub&#39;,
</span></span><span class="line"><span class="cl">    &#39;celery.worker.components:Pool&#39;,
</span></span><span class="line"><span class="cl">    &#39;celery.worker.components:Beat&#39;,
</span></span><span class="line"><span class="cl">    &#39;celery.worker.components:Timer&#39;,
</span></span><span class="line"><span class="cl">    &#39;celery.worker.components:StateDB&#39;,
</span></span><span class="line"><span class="cl">    &#39;celery.worker.components:Consumer&#39;,
</span></span><span class="line"><span class="cl">    &#39;celery.worker.autoscale:WorkerComponent&#39;,
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Consumer蓝图包括<code>{Connection, Events, Mingle, Tasks, Control, Gossip, Agent, Heart, event loop}</code>十个步骤，一般情况下除了<code>Agent</code>, 其它都会启动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[2021-11-24 15:53:13,005: DEBUG/MainProcess] | Consumer: Preparing bootsteps.
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,005: DEBUG/MainProcess] | Consumer: Building graph...
</span></span><span class="line"><span class="cl">[2021-11-24 15:53:13,038: DEBUG/MainProcess] | Consumer: New boot order: {Connection, Events, Mingle, Tasks, Control, Gossip, Agent, Heart, event loop}
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Blueprint</code>主要有2个实现函数：<code>apply</code> 创建各个step，<code>start</code> 启动各个step:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def apply(self, parent, **kwargs):
</span></span><span class="line"><span class="cl">    # 创建step
</span></span><span class="line"><span class="cl">    self._debug(&#39;Preparing bootsteps.&#39;)
</span></span><span class="line"><span class="cl">    order = self.order = []
</span></span><span class="line"><span class="cl">    steps = self.steps = self.claim_steps()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    self._debug(&#39;Building graph...&#39;)
</span></span><span class="line"><span class="cl">    for S in self._finalize_steps(steps):
</span></span><span class="line"><span class="cl">        step = S(parent, **kwargs)
</span></span><span class="line"><span class="cl">        steps[step.name] = step
</span></span><span class="line"><span class="cl">        order.append(step)
</span></span><span class="line"><span class="cl">    self._debug(&#39;New boot order: {%s}&#39;,
</span></span><span class="line"><span class="cl">                &#39;, &#39;.join(s.alias for s in self.order))
</span></span><span class="line"><span class="cl">    for step in order:
</span></span><span class="line"><span class="cl">        # 隐式的创建step
</span></span><span class="line"><span class="cl">        step.include(parent)
</span></span><span class="line"><span class="cl">    return self
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def start(self, parent):
</span></span><span class="line"><span class="cl">    # 启动蓝图
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    for i, step in enumerate(s for s in parent.steps if s is not None):
</span></span><span class="line"><span class="cl">        self._debug(&#39;Starting %s&#39;, step.alias)
</span></span><span class="line"><span class="cl">        self.started = i + 1
</span></span><span class="line"><span class="cl">        step.start(parent)
</span></span><span class="line"><span class="cl">        logger.debug(&#39;^-- substep ok&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Step</code>和子类<code>StartStopStep</code>使用enbled属性，决定step步骤的是否启用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">enabled = True
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def include_if(self, parent):
</span></span><span class="line"><span class="cl">    return self.enabled
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">def _should_include(self, parent):
</span></span><span class="line"><span class="cl">    if self.include_if(parent):
</span></span><span class="line"><span class="cl">        return True, self.create(parent)
</span></span><span class="line"><span class="cl">    return False, None
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def include(self, parent):
</span></span><span class="line"><span class="cl">    inc, ret = self._should_include(parent)
</span></span><span class="line"><span class="cl">    if inc:
</span></span><span class="line"><span class="cl">        self.obj = ret
</span></span><span class="line"><span class="cl">        parent.steps.append(self)
</span></span><span class="line"><span class="cl">    return inc
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如默认情况下StateDB会根据参数关闭:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@click.option(&#39;-S&#39;,
</span></span><span class="line"><span class="cl">              &#39;--statedb&#39;,
</span></span><span class="line"><span class="cl">              cls=CeleryOption,
</span></span><span class="line"><span class="cl">              type=click.Path(),
</span></span><span class="line"><span class="cl">              callback=lambda ctx, _, value: value or ctx.obj.app.conf.worker_state_db,
</span></span><span class="line"><span class="cl">              help_group=&#34;Worker Options&#34;,
</span></span><span class="line"><span class="cl">              help=&#34;Path to the state database. The extension &#39;.db&#39; may be &#34;
</span></span><span class="line"><span class="cl">                   &#34;appended to the filename.&#34;)
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">class StateDB(bootsteps.Step):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Bootstep that sets up between-restart state database file.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def __init__(self, w, **kwargs):
</span></span><span class="line"><span class="cl">        self.enabled = w.statedb
</span></span><span class="line"><span class="cl">        ...
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Step</code>类还有requires和last两个属性，blueprint可以根据这两个属性建立所有步骤的先后顺序:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def _find_last(self):
</span></span><span class="line"><span class="cl">    # 查找steps的尾
</span></span><span class="line"><span class="cl">    return next((C for C in self.steps.values() if C.last), None)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def _firstpass(self, steps):
</span></span><span class="line"><span class="cl">    # 查找依赖关系
</span></span><span class="line"><span class="cl">    for step in steps.values():
</span></span><span class="line"><span class="cl">        step.requires = [symbol_by_name(dep) for dep in step.requires]
</span></span><span class="line"><span class="cl">    stream = deque(step.requires for step in steps.values())
</span></span><span class="line"><span class="cl">    # 广度优先的遍历
</span></span><span class="line"><span class="cl">    while stream:
</span></span><span class="line"><span class="cl">        for node in stream.popleft():
</span></span><span class="line"><span class="cl">            node = symbol_by_name(node)
</span></span><span class="line"><span class="cl">            if node.name not in self.steps:
</span></span><span class="line"><span class="cl">                steps[node.name] = node
</span></span><span class="line"><span class="cl">            stream.append(node.requires)
</span></span></code></pre></td></tr></table>
</div>
</div><p>Consumer这个特殊的Step是这样嵌套启动Consumer蓝图的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Consumer(bootsteps.StartStopStep):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Bootstep starting the Consumer blueprint.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def create(self, w):
</span></span><span class="line"><span class="cl">        # consumer_cls就是Consumer蓝图
</span></span><span class="line"><span class="cl">        c = w.consumer = self.instantiate(
</span></span><span class="line"><span class="cl">            w.consumer_cls, w.process_task,
</span></span><span class="line"><span class="cl">            hostname=w.hostname,
</span></span><span class="line"><span class="cl">            task_events=w.task_events,
</span></span><span class="line"><span class="cl">            init_callback=w.ready_callback,
</span></span><span class="line"><span class="cl">            initial_prefetch_count=prefetch_count,
</span></span><span class="line"><span class="cl">            pool=w.pool,
</span></span><span class="line"><span class="cl">            timer=w.timer,
</span></span><span class="line"><span class="cl">            app=w.app,
</span></span><span class="line"><span class="cl">            controller=w,
</span></span><span class="line"><span class="cl">            hub=w.hub,
</span></span><span class="line"><span class="cl">            worker_options=w.options,
</span></span><span class="line"><span class="cl">            disable_rate_limits=w.disable_rate_limits,
</span></span><span class="line"><span class="cl">            prefetch_multiplier=w.prefetch_multiplier,
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">        return c
</span></span></code></pre></td></tr></table>
</div>
</div><p>celery将启动过程分成多个step，每个step承担不同的功能，不同的step又组合成多个蓝图，这种方式可以灵活的定义启动流程，并且让业务功能解耦，更易维护。下面我们继续学习其中的一些step。</p>
<h2 id="connection-step实现amqp协议连接">Connection-Step实现AMQP协议连接</h2>
<p>Connection-Step主要功能是创建connection连接:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Connection(bootsteps.StartStopStep):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Service managing the consumer broker connection.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def __init__(self, c, **kwargs):
</span></span><span class="line"><span class="cl">        c.connection = None
</span></span><span class="line"><span class="cl">        super().__init__(c, **kwargs)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def start(self, c):
</span></span><span class="line"><span class="cl">        # 创建连接
</span></span><span class="line"><span class="cl">        c.connection = c.connect()
</span></span><span class="line"><span class="cl">        info(&#39;Connected to %s&#39;, c.connection.as_uri())
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="pool-step实现并发模型">Pool-Step实现并发模型</h2>
<p>Pool-Step主要功能是启动一个调度池:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Initialize bootsteps
</span></span><span class="line"><span class="cl">self.pool_cls = _concurrency.get_implementation(self.pool_cls)
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">def create(self, w):
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    # 启动concurrency模型
</span></span><span class="line"><span class="cl">    pool = w.pool = self.instantiate(
</span></span><span class="line"><span class="cl">            w.pool_cls, w.min_concurrency,
</span></span><span class="line"><span class="cl">            initargs=(w.app, w.hostname),
</span></span><span class="line"><span class="cl">            maxtasksperchild=w.max_tasks_per_child,
</span></span><span class="line"><span class="cl">            max_memory_per_child=w.max_memory_per_child,
</span></span><span class="line"><span class="cl">            timeout=w.time_limit,
</span></span><span class="line"><span class="cl">            soft_timeout=w.soft_time_limit,
</span></span><span class="line"><span class="cl">            putlocks=w.pool_putlocks and threaded,
</span></span><span class="line"><span class="cl">            lost_worker_timeout=w.worker_lost_wait,
</span></span><span class="line"><span class="cl">            threads=threaded,
</span></span><span class="line"><span class="cl">            max_restarts=max_restarts,
</span></span><span class="line"><span class="cl">            allow_restart=allow_restart,
</span></span><span class="line"><span class="cl">            forking_enable=True,
</span></span><span class="line"><span class="cl">            semaphore=semaphore,
</span></span><span class="line"><span class="cl">            sched_strategy=self.optimization,
</span></span><span class="line"><span class="cl">            app=w.app,
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">    return pool
</span></span></code></pre></td></tr></table>
</div>
</div><p>并发模型主要包括下面一些实现，比如基于fork的多进程，基于eventlet和gevent的协程和多线程等:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ALIASES = {
</span></span><span class="line"><span class="cl">    &#39;prefork&#39;: &#39;celery.concurrency.prefork:TaskPool&#39;,
</span></span><span class="line"><span class="cl">    &#39;eventlet&#39;: &#39;celery.concurrency.eventlet:TaskPool&#39;,
</span></span><span class="line"><span class="cl">    &#39;gevent&#39;: &#39;celery.concurrency.gevent:TaskPool&#39;,
</span></span><span class="line"><span class="cl">    &#39;solo&#39;: &#39;celery.concurrency.solo:TaskPool&#39;,
</span></span><span class="line"><span class="cl">    &#39;processes&#39;: &#39;celery.concurrency.prefork:TaskPool&#39;,  # XXX compat alias
</span></span><span class="line"><span class="cl">    &#39;threads&#39;: &#39;celery.concurrency.thread:TaskPool&#39;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def get_implementation(cls):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Return pool implementation by name.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    return symbol_by_name(cls, ALIASES)
</span></span></code></pre></td></tr></table>
</div>
</div><p>在前一篇的日志中，我们知道默认使用的是prefork也就是多线程模式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class TaskPool(BasePool):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Multiprocessing Pool implementation.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    # billiard提供的池模式
</span></span><span class="line"><span class="cl">    BlockingPool = BlockingPool
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>TaskPool的实现主要依赖billiard库，我们以后再行介绍，这里简单了解一下celery的并发模型都在concurrency模块之下即可。</p>
<h2 id="evloop-step实现事件循环">Evloop-Step实现事件循环</h2>
<p>Evloop-Step是由Consumer blueprint启动:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Evloop(bootsteps.StartStopStep):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Event loop service.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Note:
</span></span><span class="line"><span class="cl">        This is always started last.
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    # [2021-11-24 20:08:31,037: DEBUG/MainProcess] | Consumer: Starting event loop
</span></span><span class="line"><span class="cl">    label = &#39;event loop&#39;
</span></span><span class="line"><span class="cl">    last = True
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def start(self, c):
</span></span><span class="line"><span class="cl">        self.patch_all(c)
</span></span><span class="line"><span class="cl">        c.loop(*c.loop_args())
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的loop在consumer中定义, 默认使用异步循环(asynloop)和同步循环(synloop)中的同步循环:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def synloop(obj, connection, consumer, blueprint, hub, qos,
</span></span><span class="line"><span class="cl">            heartbeat, clock, hbrate=2.0, **kwargs):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Fallback blocking event loop for transports that doesn&#39;t support AIO.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    RUN = bootsteps.RUN
</span></span><span class="line"><span class="cl">    on_task_received = obj.create_task_handler()
</span></span><span class="line"><span class="cl">    perform_pending_operations = obj.perform_pending_operations
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    consumer.on_message = on_task_received
</span></span><span class="line"><span class="cl">    consumer.consume()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    obj.on_ready()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while blueprint.state == RUN and obj.connection:
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            perform_pending_operations()
</span></span><span class="line"><span class="cl">            connection.drain_events(timeout=2.0)
</span></span><span class="line"><span class="cl">        except socket.timeout:
</span></span><span class="line"><span class="cl">           ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>循环中主要功能是:</p>
<ol>
<li>设定消息的消费函数on_message</li>
<li>使用while循环阻塞监听</li>
<li>使用connection.drain_events消费消息(在kombu的文章中有过介绍)</li>
</ol>
<p>因为synloop会阻塞，所以需要设置step为<strong>last</strong>，确保在蓝图的最后启动。</p>
<h2 id="consumer-blueprint实现任务调度">Consumer-Blueprint实现任务调度</h2>
<p>我们再查看celery的任务处理日志:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[2021-11-24 21:33:50,535: INFO/MainProcess] Received task: myapp.add[e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2]
</span></span><span class="line"><span class="cl">[2021-11-24 21:33:50,535: DEBUG/MainProcess] TaskPool: Apply &lt;function _trace_task_ret at 0x7fe6086ac280&gt; (args:(&#39;myapp.add&#39;, &#39;e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2&#39;, {&#39;lang&#39;: &#39;py&#39;, &#39;task&#39;: &#39;myapp.add&#39;, &#39;id&#39;: &#39;e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2&#39;, &#39;shadow&#39;: None, &#39;eta&#39;: None, &#39;expires&#39;: None, &#39;group&#39;: None, &#39;group_index&#39;: None, &#39;retries&#39;: 0, &#39;timelimit&#39;: [None, None], &#39;root_id&#39;: &#39;e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2&#39;, &#39;parent_id&#39;: None, &#39;argsrepr&#39;: &#39;(16, 16)&#39;, &#39;kwargsrepr&#39;: &#39;{}&#39;, &#39;origin&#39;: &#39;gen83110@192.168.5.28&#39;, &#39;reply_to&#39;: &#39;63862dbb-9d82-3bdd-b7fb-03580941362a&#39;, &#39;correlation_id&#39;: &#39;e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2&#39;, &#39;hostname&#39;: &#39;celery@192.168.5.28&#39;, &#39;delivery_info&#39;: {&#39;exchange&#39;: &#39;&#39;, &#39;routing_key&#39;: &#39;celery&#39;, &#39;priority&#39;: 0, &#39;redelivered&#39;: None}, &#39;args&#39;: [16, 16], &#39;kwargs&#39;: {}}, b&#39;[[16, 16], {}, {&#34;callbacks&#34;: null, &#34;errbacks&#34;: null, &#34;chain&#34;: null, &#34;chord&#34;: null}]&#39;, &#39;application/json&#39;, &#39;utf-8&#39;) kwargs:{})
</span></span><span class="line"><span class="cl">[2021-11-24 21:33:50,536: DEBUG/MainProcess] Task accepted: myapp.add[e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2] pid:83086
</span></span><span class="line"><span class="cl">[2021-11-24 21:33:50,537: INFO/ForkPoolWorker-8] Task myapp.add[e9bb4aa0-8280-443f-a5ed-3deb0a0b99c2] succeeded in 0.000271957000000711s: 32
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现celery的worker在主进程(MainProcess)中接收到task后，会派发给子进程(ForkPoolWorker-8)执行。</p>
<p>前面synloop的消费函数on_message实际上是Consumer(Blueprint)的create_task_handler:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def create_task_handler(self, promise=promise):
</span></span><span class="line"><span class="cl">    strategies = self.strategies
</span></span><span class="line"><span class="cl">    on_unknown_message = self.on_unknown_message
</span></span><span class="line"><span class="cl">    on_unknown_task = self.on_unknown_task
</span></span><span class="line"><span class="cl">    on_invalid_task = self.on_invalid_task
</span></span><span class="line"><span class="cl">    callbacks = self.on_task_message
</span></span><span class="line"><span class="cl">    call_soon = self.call_soon
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    def on_task_received(message):
</span></span><span class="line"><span class="cl">        type_ = message.headers[&#39;task&#39;]  
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        strategy = strategies[type_]
</span></span><span class="line"><span class="cl">        strategy(
</span></span><span class="line"><span class="cl">                        message, payload,
</span></span><span class="line"><span class="cl">                        promise(call_soon, (message.ack_log_error,)),
</span></span><span class="line"><span class="cl">                        promise(call_soon, (message.reject_log_error,)),
</span></span><span class="line"><span class="cl">                        callbacks,
</span></span><span class="line"><span class="cl">                    )
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">    return on_task_received
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于消息和任务的处理，celery提供了默认的执行策略:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># celery/worker/strategy.py:22
</span></span><span class="line"><span class="cl">def default(task, app, consumer,
</span></span><span class="line"><span class="cl">            info=logger.info, error=logger.error, task_reserved=task_reserved,
</span></span><span class="line"><span class="cl">            to_system_tz=timezone.to_system, bytes=bytes,
</span></span><span class="line"><span class="cl">            proto1_to_proto2=proto1_to_proto2):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Default task execution strategy.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    # task event related
</span></span><span class="line"><span class="cl">    # (optimized to avoid calling request.send_event)
</span></span><span class="line"><span class="cl">    handle = consumer.on_task_request
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    Request = symbol_by_name(task.Request)
</span></span><span class="line"><span class="cl">    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    revoked_tasks = consumer.controller.state.revoked
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def task_message_handler(message, body, ack, reject, callbacks,
</span></span><span class="line"><span class="cl">                             to_timestamp=to_timestamp):
</span></span><span class="line"><span class="cl">        ....
</span></span><span class="line"><span class="cl">        req = Req(
</span></span><span class="line"><span class="cl">            message,
</span></span><span class="line"><span class="cl">            on_ack=ack, on_reject=reject, app=app, hostname=hostname,
</span></span><span class="line"><span class="cl">            eventer=eventer, task=task, connection_errors=connection_errors,
</span></span><span class="line"><span class="cl">            body=body, headers=headers, decoded=decoded, utc=utc,
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        info(&#39;Received task: %s&#39;, req)
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        handle(req)
</span></span><span class="line"><span class="cl">    return task_message_handler
</span></span></code></pre></td></tr></table>
</div>
</div><p>default策略主要做了下面2件事:</p>
<ul>
<li>创建请求对象Request</li>
<li>使用handle处理request对象</li>
</ul>
<p>Request对象的执行是调用pool的执行方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def execute_using_pool(self, pool, **kwargs):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Used by the worker to send this task to the pool.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    result = pool.apply_async(
</span></span><span class="line"><span class="cl">            trace_task_ret,
</span></span><span class="line"><span class="cl">            args=(self._type, task_id, self._request_dict, self._body,
</span></span><span class="line"><span class="cl">                  self._content_type, self._content_encoding),
</span></span><span class="line"><span class="cl">            accept_callback=self.on_accepted,
</span></span><span class="line"><span class="cl">            timeout_callback=self.on_timeout,
</span></span><span class="line"><span class="cl">            callback=self.on_success,
</span></span><span class="line"><span class="cl">            error_callback=self.on_failure,
</span></span><span class="line"><span class="cl">            soft_timeout=soft_time_limit or task.soft_time_limit,
</span></span><span class="line"><span class="cl">            timeout=time_limit or task.time_limit,
</span></span><span class="line"><span class="cl">            correlation_id=task_id,
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">        # cannot create weakref to None
</span></span><span class="line"><span class="cl">        self._apply_result = maybe(ref, result)
</span></span><span class="line"><span class="cl">    return result
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样远程的任务请求就派发给Pool进行执行, pool如何执行task同样以后再介绍。</p>
<h2 id="mingle-step和gossip-step实现worker分布式协作">Mingle-Step和Gossip-Step实现worker分布式协作</h2>
<p>celery作为一款分布式任务调度框架，多个worker的协作由Mingle和Gossip两个step提供。我们先看Mingle-Step的日志:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[2021-12-12 13:37:56,632: DEBUG/MainProcess] | Consumer: Starting Mingle
</span></span><span class="line"><span class="cl">[2021-12-12 13:37:56,632: INFO/MainProcess] mingle: searching for neighbors
</span></span><span class="line"><span class="cl">[2021-12-12 13:37:57,674: INFO/MainProcess] mingle: all alone
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>Mingle-Step实现多个worker节点的同步通讯:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def start(self, c):
</span></span><span class="line"><span class="cl">    self.sync(c)
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">def sync(self, c):
</span></span><span class="line"><span class="cl">    info(&#39;mingle: searching for neighbors&#39;)
</span></span><span class="line"><span class="cl">    replies = self.send_hello(c)
</span></span><span class="line"><span class="cl">    if replies:
</span></span><span class="line"><span class="cl">        info(&#39;mingle: sync with %s nodes&#39;,
</span></span><span class="line"><span class="cl">             len([reply for reply, value in replies.items() if value]))
</span></span><span class="line"><span class="cl">        [self.on_node_reply(c, nodename, reply)
</span></span><span class="line"><span class="cl">         for nodename, reply in replies.items() if reply]
</span></span><span class="line"><span class="cl">        info(&#39;mingle: sync complete&#39;)
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        info(&#39;mingle: all alone&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到Mingle启动后，发送hello消息，然后对其它节点的回应进行处理。hello的发送是这样的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def send_hello(self, c):
</span></span><span class="line"><span class="cl">    inspect = c.app.control.inspect(timeout=1.0, connection=c.connection)
</span></span><span class="line"><span class="cl">    our_revoked = c.controller.state.revoked
</span></span><span class="line"><span class="cl">    replies = inspect.hello(c.hostname, our_revoked._data) or {}
</span></span><span class="line"><span class="cl">    replies.pop(c.hostname, None)  # delete my own response
</span></span><span class="line"><span class="cl">    return replies
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl"># celery/app/control.py
</span></span><span class="line"><span class="cl">def hello(self, from_node, revoked=None):
</span></span><span class="line"><span class="cl">    return self._request(&#39;hello&#39;, from_node=from_node, revoked=revoked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于回应的主要处理就是对当前worker的LamportClock进行校正。:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def on_node_reply(self, c, nodename, reply):
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    c.app.clock.adjust(clock) if clock else c.app.clock.forward()
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>Gossip-Step的功能会复杂一些，不像Mingle是一次性的，它是一个持续的过程。下面是它的日志，清晰展示会持续的监听:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[2021-12-05 15:59:19,088: DEBUG/MainProcess] w2@bogon joined the party[2021-12-12 13:37:58,096: DEBUG/MainProcess] w2@bogon joined the party
</span></span><span class="line"><span class="cl">[2021-12-12 14:52:49,259: INFO/MainProcess] missed heartbeat from w2@bogon
</span></span><span class="line"><span class="cl">[2021-12-12 14:52:49,262: DEBUG/MainProcess] w2@bogon joined the party
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">[2021-12-12 16:10:54,112: DEBUG/MainProcess] w2@bogon left
</span></span></code></pre></td></tr></table>
</div>
</div><p>Gossip是一种算法，又称流行病算法，其图示如下:</p>
<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20211212195252.png" alt="gossip"></p>
<p>简单的说在Gossip算法中网络节点每次向自己关联的节点广播消息，直到网络中所有节点都收到消息。</p>
<p>celery的gossip处理消息的过程是创建自己的Consumer和定时器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def get_consumers(self, channel):
</span></span><span class="line"><span class="cl">    # 定时处理worker激活事件
</span></span><span class="line"><span class="cl">    self.register_timer()
</span></span><span class="line"><span class="cl">    # 消息消费者
</span></span><span class="line"><span class="cl">    ev = self.Receiver(channel, routing_key=&#39;worker.#&#39;,
</span></span><span class="line"><span class="cl">                       queue_ttl=self.heartbeat_interval)
</span></span><span class="line"><span class="cl">    return [Consumer(
</span></span><span class="line"><span class="cl">        channel,
</span></span><span class="line"><span class="cl">        queues=[ev.queue],
</span></span><span class="line"><span class="cl">        on_message=partial(self.on_message, ev.event_from_message),
</span></span><span class="line"><span class="cl">        no_ack=True
</span></span><span class="line"><span class="cl">    )]
</span></span></code></pre></td></tr></table>
</div>
</div><p>定时器负责处理其它节点的活跃状态, 如果节点不活跃，将它标记为脏节点，进行节点丢失处理，然后移除节点:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def periodic(self):
</span></span><span class="line"><span class="cl">    workers = self.state.workers
</span></span><span class="line"><span class="cl">    dirty = set()
</span></span><span class="line"><span class="cl">    for worker in workers.values():
</span></span><span class="line"><span class="cl">        if not worker.alive:
</span></span><span class="line"><span class="cl">            dirty.add(worker)
</span></span><span class="line"><span class="cl">            self.on_node_lost(worker)
</span></span><span class="line"><span class="cl">    for worker in dirty:
</span></span><span class="line"><span class="cl">        workers.pop(worker.hostname, None)
</span></span></code></pre></td></tr></table>
</div>
</div><p>消费的消息，又分成2种类型: 选举消息和其它消息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def on_message(self, prepare, message):
</span></span><span class="line"><span class="cl">    _type = message.delivery_info[&#39;routing_key&#39;]
</span></span><span class="line"><span class="cl">    try:
</span></span><span class="line"><span class="cl">        # 选举事件
</span></span><span class="line"><span class="cl">        handler = self.event_handlers[_type]
</span></span><span class="line"><span class="cl">    except KeyError:
</span></span><span class="line"><span class="cl">        pass
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        return handler(message.payload)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # proto2: hostname in header; proto1: in body
</span></span><span class="line"><span class="cl">    hostname = (message.headers.get(&#39;hostname&#39;) or
</span></span><span class="line"><span class="cl">                message.payload[&#39;hostname&#39;])
</span></span><span class="line"><span class="cl">    if hostname != self.hostname:
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        # 其它事件
</span></span><span class="line"><span class="cl">        _, event = prepare(message.payload)
</span></span><span class="line"><span class="cl">            self.update_state(event)
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        self.clock.forward()
</span></span></code></pre></td></tr></table>
</div>
</div><p>选举类的消息是处理选举消息和选举ack消息:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">self.event_handlers = {
</span></span><span class="line"><span class="cl">            &#39;worker.elect&#39;: self.on_elect,
</span></span><span class="line"><span class="cl">            &#39;worker.elect.ack&#39;: self.on_elect_ack,
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def on_elect(self, event):
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def on_elect_ack(self, event):
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>其它事件主要是节点的上下线之类:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">self.state = c.app.events.State(
</span></span><span class="line"><span class="cl">                on_node_join=self.on_node_join,
</span></span><span class="line"><span class="cl">                on_node_leave=self.on_node_leave,
</span></span><span class="line"><span class="cl">                max_tasks_in_memory=1,
</span></span><span class="line"><span class="cl">            )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def on_node_join(self, worker):
</span></span><span class="line"><span class="cl">    debug(&#39;%s joined the party&#39;, worker.hostname)
</span></span><span class="line"><span class="cl">    self._call_handlers(self.on.node_join, worker)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def on_node_leave(self, worker):
</span></span><span class="line"><span class="cl">    debug(&#39;%s left&#39;, worker.hostname)
</span></span><span class="line"><span class="cl">    self._call_handlers(self.on.node_leave, worker)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结</h2>
<p>我们通过解析celery的两个Blueprint，了解到celery worker的启动流程包括建立和broker之间的AMQP协议连接，使用进程池/线程池/协程池方式处理任务，使用hello消息进行worker节点之间的LamportClock时钟校时，使用Gossip协议进行worker节点之间的通讯协作。在多进程情况下，每次的任务都先被主进程获取，然后分配给进程池中的子进程进行执行。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/">https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">shawn</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-12-12
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/celery/">celery</a>
          <a href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/docker/uid_gosu/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">容器安全漏洞实验</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/python/celery-6/">
            <span class="next-text nav-default">Celery 源码解析 - 6</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '2021-12-12 22:55:38 \u002b0800 CST',
        title: 'Celery 源码解析 - 7',
        link: decodeURI(location.href),
        desc: '本章我们从celery的蓝图学习celery的实现细节。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一',
        owner: 'game404',
        repo: 'game404.github.io',
        oauth: {
          client_id: '28a86ccaa3184b49dfc4',
          client_secret: '15ab0f7c1445c0afb5e3d7a8995c89f2fd081eb7'
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:studyoo@foxmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/game404" class="iconfont icon-github" title="github"></a>
      <a href="https://juejin.im/user/593f44b8da2f60006736604e" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://game404.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>game404</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-137813525-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
