<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>再聊我的源码阅读方法-xmlrpc源码慢读 - 游戏不存在</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="shawn" /><meta name="description" content="之前介绍我的源码阅读方法，有粉丝朋友说很有帮助，认为是授人予鱼。这是过誉了，也让我很受鼓舞，这次带来另外一种阅读方法，希望对大家也有帮助。 在" /><meta name="keywords" content="game, docker, kubernetes, python, go,  microservice" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://game404.github.io/post/python/xmlrpc-server-slow/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="再聊我的源码阅读方法-xmlrpc源码慢读" />
<meta property="og:description" content="之前介绍我的源码阅读方法，有粉丝朋友说很有帮助，认为是授人予鱼。这是过誉了，也让我很受鼓舞，这次带来另外一种阅读方法，希望对大家也有帮助。 在" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://game404.github.io/post/python/xmlrpc-server-slow/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-20T23:13:57+08:00" />
<meta property="article:modified_time" content="2021-05-20T23:13:57+08:00" />

<meta itemprop="name" content="再聊我的源码阅读方法-xmlrpc源码慢读">
<meta itemprop="description" content="之前介绍我的源码阅读方法，有粉丝朋友说很有帮助，认为是授人予鱼。这是过誉了，也让我很受鼓舞，这次带来另外一种阅读方法，希望对大家也有帮助。 在"><meta itemprop="datePublished" content="2021-05-20T23:13:57+08:00" />
<meta itemprop="dateModified" content="2021-05-20T23:13:57+08:00" />
<meta itemprop="wordCount" content="6192">
<meta itemprop="keywords" content="rpc,源码,阅读方法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="再聊我的源码阅读方法-xmlrpc源码慢读"/>
<meta name="twitter:description" content="之前介绍我的源码阅读方法，有粉丝朋友说很有帮助，认为是授人予鱼。这是过誉了，也让我很受鼓舞，这次带来另外一种阅读方法，希望对大家也有帮助。 在"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">游戏不存在</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">游戏不存在</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">再聊我的源码阅读方法-xmlrpc源码慢读</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-05-20 </span>
        <div class="post-category">
            <a href="/categories/python/"> python </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#帮助和依赖分析">帮助和依赖分析</a></li>
    <li><a href="#simplexmlrpcdispatcher分析">SimpleXMLRPCDispatcher分析</a></li>
    <li><a href="#simplexmlrpcrequesthandler分析">SimpleXMLRPCRequestHandler分析</a></li>
    <li><a href="#simplexmlrpcserver-分析">SimpleXMLRPCServer 分析</a></li>
    <li><a href="#multipathxmlrpcserver--cgixmlrpcrequesthandler">MultiPathXMLRPCServer &amp;&amp; CGIXMLRPCRequestHandler</a></li>
    <li><a href="#rpc-doc">rpc-doc</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#小技巧">小技巧</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>之前介绍我的源码阅读方法，有粉丝朋友说很有帮助，认为是授人予鱼。这是过誉了，也让我很受鼓舞，这次带来另外一种阅读方法，希望对大家也有帮助。</p>
<p>在前文中我介绍了两种源码阅读方法：</p>
<ol>
<li>概读法，对一个项目，跟随API，进行核心功能实现的阅读，跳过异常，分支等功能，快速了解项目底层实现原理</li>
<li>历史对比法，对比源码的版本修改历史，分析新增功能如何实现和扩展，分析如何修改bug。</li>
</ol>
<p>如果说概读法可以了解一个项目是what。历史对比可以理解一段代码why这样写。这次我介绍的 <strong>慢读法</strong> 就是how。我们一行一行的去看代码，分析功能实现的所有细节。慢读法，可以学习如何编写代码，提高自己的编码水准。慢读法，需要有点耐性，尽量做到不漏过一行一字。像古代一字之师郑谷把僧人齐己的“前村深雪里，昨夜数枝开” 诗句修改成 “前村深雪里，昨夜一枝开”一样，一点一点去推敲。</p>
<p>本次慢读法使用的是python3.8中的xmlrpc-server部分，全文大概1000行，我们只阅读上半部分600行，大概30分钟内可以读完，时间紧张的朋友欢迎收藏了慢慢看。</p>
<ul>
<li>帮助和依赖分析</li>
<li>SimpleXMLRPCDispatcher分析</li>
<li>SimpleXMLRPCRequestHandler分析</li>
<li>SimpleXMLRPCServer 分析</li>
<li>MultiPathXMLRPCServer &amp;&amp; CGIXMLRPCRequestHandler</li>
<li>rpc-doc</li>
<li>小结</li>
</ul>
<h2 id="帮助和依赖分析">帮助和依赖分析</h2>
<p>我们常说注释是代码的一部分，xmlrpc-server中的注释很详尽，对我们学习具有指导意义。比如头部注释中，很详细的介绍了如何扩展SimpleXMLRPCServer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="line"><span class="cl"><span class="mf">4.</span> <span class="n">Subclass</span> <span class="n">SimpleXMLRPCServer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MathServer</span><span class="p">(</span><span class="n">SimpleXMLRPCServer</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># We are forcing the &#39;export_&#39; prefix on methods that are</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># callable through XML-RPC to prevent potential security</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># problems</span>
</span></span><span class="line"><span class="cl">            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;export_&#39;</span> <span class="o">+</span> <span class="n">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;method &#34;</span><span class="si">%s</span><span class="s1">&#34; is not supported&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">export_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server</span> <span class="o">=</span> <span class="n">MathServer</span><span class="p">((</span><span class="s2">&#34;localhost&#34;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>MathServer方法约定对外暴露的rpc方法使用<code>export_</code>前缀，这个策略对服务程序管理非常有用，可以在语法层级的private和public之上增加business类型的方法。和nodejs中使用export导出函数外部接口类似。</p>
<p>模块依赖部分，import的try-except语句可以帮助我们更好的适配依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">try:
</span></span><span class="line"><span class="cl">    import fcntl
</span></span><span class="line"><span class="cl">except ImportError:
</span></span><span class="line"><span class="cl">    fcntl = None
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码还不太说明问题，下面例子会更直观。优先导入速度更快的simplejson, 不存在的情况下再使用默认的json:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># requests/compat.py
</span></span><span class="line"><span class="cl">try:
</span></span><span class="line"><span class="cl">    import simplejson as json
</span></span><span class="line"><span class="cl">except ImportError:
</span></span><span class="line"><span class="cl">    import json
</span></span></code></pre></td></tr></table>
</div>
</div><p>模块依赖还有一个源码阅读的小技巧：依赖越少的模块，相对容易阅读，应该最先阅读。比如下面的sqlalchemy的sql模块构成，是一个金字塔结构，阅读时候从最顶端的visitors开始更容易上手：</p>
<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/packages.png" alt="sqlalchmy金字塔结构图"></p>
<p>resolve_dotted_attribute函数链式查找对象的方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def resolve_dotted_attribute(obj, attr, allow_dotted_names=True):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;resolve_dotted_attribute(a, &#39;b.c.d&#39;) =&gt; a.b.c.d
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Resolves a dotted attribute name to an object.  Raises
</span></span><span class="line"><span class="cl">    an AttributeError if any attribute in the chain starts with a &#39;_&#39;.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    If the optional allow_dotted_names argument is false, dots are not
</span></span><span class="line"><span class="cl">    supported and this function operates similar to getattr(obj, attr).
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if allow_dotted_names:
</span></span><span class="line"><span class="cl">        attrs = attr.split(&#39;.&#39;)
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        attrs = [attr]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for i in attrs:
</span></span><span class="line"><span class="cl">        if i.startswith(&#39;_&#39;):
</span></span><span class="line"><span class="cl">            raise AttributeError(
</span></span><span class="line"><span class="cl">                &#39;attempt to access private attribute &#34;%s&#34;&#39; % i
</span></span><span class="line"><span class="cl">                )
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">            obj = getattr(obj,i)
</span></span><span class="line"><span class="cl">    return obj
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>函数注释很清晰的介绍了功能:(a, &lsquo;b.c.d&rsquo;) =&gt; a.b.c.d, 查找a的b属性的c属性的d属性，这是一个链式调用</li>
<li>这里使用列表循环来实现递归查找，如果用递归肯定是查找a的b属性，然后把b当做参数对象再查找c&hellip;,列表循环显然更优</li>
<li>将attr处理成attrs数组，让后面的代码逻辑更清晰</li>
<li>属性查找时候遵循对象的私有属性使用<code>_</code>的约定</li>
<li>异常处理，程序可以抛出 <code>AttributeError('attempt to access private attribute &quot;%s&quot;' % i)</code> 这样有自定义消息的message，帮助问题排查</li>
</ul>
<p>list_public_methods查找对象的所有公开方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def list_public_methods(obj):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return [member for member in dir(obj)
</span></span><span class="line"><span class="cl">                if not member.startswith(&#39;_&#39;) and
</span></span><span class="line"><span class="cl">                    callable(getattr(obj, member))]
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>魔法函数<code>dir</code>可以列出对象所有的属性和方法；魔法函数<code>getattr</code>可以根据字符串名称动态获取对象的方法/属性</li>
<li><code>callable</code>方法可以判断一个对象是不是一个方法，因为python中没有<code>isinstance(x,function)</code>的方法</li>
<li><code>for in if</code>语句可以对生成式根据指定条件进行过滤</li>
</ul>
<h2 id="simplexmlrpcdispatcher分析">SimpleXMLRPCDispatcher分析</h2>
<p>SimpleXMLRPCDispatcher负责和xmlrpc服务的核心逻辑之一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class SimpleXMLRPCDispatcher:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def __init__(self, allow_none=False, encoding=None,
</span></span><span class="line"><span class="cl">                 use_builtin_types=False):
</span></span><span class="line"><span class="cl">        self.funcs = {}
</span></span><span class="line"><span class="cl">        self.instance = None
</span></span><span class="line"><span class="cl">        self.allow_none = allow_none
</span></span><span class="line"><span class="cl">        self.encoding = encoding or &#39;utf-8&#39;
</span></span><span class="line"><span class="cl">        self.use_builtin_types = use_builtin_types
</span></span></code></pre></td></tr></table>
</div>
</div><p>类定义除上面的写法外，还有一种是 <code>class SimpleXMLRPCDispatcher(object)</code>, 我一般喜欢用这种。如果大家考古，可以发现在python2中还有新式类和旧式类的说法。在python3中都是新式类，不管使用哪种写法。</p>
<p>SimpleXMLRPCDispatcher的构造函数，我们可以思考下面写法的差异:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def __init__(self, allow_none=False, encoding=&#34;utf-8&#34;,
</span></span><span class="line"><span class="cl">                 use_builtin_types=False):
</span></span><span class="line"><span class="cl">    self.encoding = encoding
</span></span></code></pre></td></tr></table>
</div>
</div><p>encoding关键字参数，默认值是<strong>utf-8</strong>。相对来说，没有源码健壮。比如错误的传入 <code>encoding=None</code> 参数的时候，默认的encoding就丢失了，源码就不会存在这个问题。</p>
<p>构造函数中字典<code>self.funcs = {}</code> or <code>self.funcs = dict()</code> 那种更优呢？先看测试数据, 用数据说话:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># python3 -m timeit -n 1000000 -r 5 -v &#39;dict()&#39;
</span></span><span class="line"><span class="cl">raw times: 115 msec, 98.4 msec, 99.8 msec, 99.3 msec, 98.7 msec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1000000 loops, best of 5: 98.4 nsec per loop
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># python3 -m timeit -n 1000000 -r 5 -v &#39;{}&#39;
</span></span><span class="line"><span class="cl">raw times: 23.8 msec, 20.8 msec, 19.2 msec, 18.8 msec, 18.6 msec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1000000 loops, best of 5: 18.6 nsec per loop
</span></span></code></pre></td></tr></table>
</div>
</div><p>测试可见，使用 <code>{}</code> 效率更高。为什么呢，我们可以查看二者的字节码对比:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  1           0 LOAD_NAME                0 (dict)
</span></span><span class="line"><span class="cl">              2 CALL_FUNCTION            0
</span></span><span class="line"><span class="cl">              4 POP_TOP
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  3           6 BUILD_MAP                0
</span></span><span class="line"><span class="cl">              8 POP_TOP
</span></span><span class="line"><span class="cl">             10 LOAD_CONST               0 (None)
</span></span><span class="line"><span class="cl">             12 RETURN_VALUE
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>dict()</code>实际上是一次函数调用，相对资源消耗更大。类似的还有<code>list() vs []</code>，所以大家初始化字典和列表都推荐使用<code>{}</code>和<code>[]</code>关键字语法。</p>
<p>register_instance函数用于dispatcher接受外部注册的服务对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def register_instance(self, instance, allow_dotted_names=False):
</span></span><span class="line"><span class="cl">    self.instance = instance
</span></span><span class="line"><span class="cl">    self.allow_dotted_names = allow_dotted_names
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>属性 allow_dotted_names 没有在构造函数中初始化，这个其实是不符合规范。如果我们自己的代码，IDE会有智能提示，如下图：</li>
</ul>
<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20210517140046.png" alt="属性初始化"></p>
<p>额外提一点，代码整洁就是在IDE中不出现黄色的<code>warnings</code>和<code>weak warnings</code>，绿色的<code>typos</code>， 当然红色的 <code>error</code> 更不应该出现。</p>
<p>register_function函数用于dispatcher接受外部注册的服务函数。和服务对象注册不一样，对象可以理解为一组函数的集合，这里是单个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def register_function(self, function=None, name=None):
</span></span><span class="line"><span class="cl">    # decorator factory
</span></span><span class="line"><span class="cl">    if function is None:
</span></span><span class="line"><span class="cl">        return partial(self.register_function, name=name)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if name is None:
</span></span><span class="line"><span class="cl">        name = function.__name__
</span></span><span class="line"><span class="cl">    self.funcs[name] = function
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return function
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>functools.partial函数非常有用，可以帮助我们固定某个函数的参数，减少重复代码。</li>
<li>参数function和name先后顺序也是有讲究的。name在后，这样可以不用传name参数，使用 <code>register_function(some_func)</code> 把function参数当做位置参数使用。如果name在前面，则无法这样使用。</li>
</ul>
<p>register_introspection_functions方法注册了xmlrpc-server的一些帮助信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def register_introspection_functions(self):
</span></span><span class="line"><span class="cl">    self.funcs.update({&#39;system.listMethods&#39; : self.system_listMethods,
</span></span><span class="line"><span class="cl">                  &#39;system.methodSignature&#39; : self.system_methodSignature,
</span></span><span class="line"><span class="cl">                  &#39;system.methodHelp&#39; : self.system_methodHelp})
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>注意字典的update方法，同样还有setdefault，这些都是相对其它语言比较少见的，学会了代码更pythonic</li>
</ul>
<p>现在先跳跃一下，查看注册的几个帮助方法，先看system_listMethods：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def system_listMethods(self):
</span></span><span class="line"><span class="cl">    methods = set(self.funcs.keys())
</span></span><span class="line"><span class="cl">    if self.instance is not None:
</span></span><span class="line"><span class="cl">        # Instance can implement _listMethod to return a list of
</span></span><span class="line"><span class="cl">        # methods
</span></span><span class="line"><span class="cl">        if hasattr(self.instance, &#39;_listMethods&#39;):
</span></span><span class="line"><span class="cl">            methods |= set(self.instance._listMethods())
</span></span><span class="line"><span class="cl">        # if the instance has a _dispatch method then we
</span></span><span class="line"><span class="cl">        # don&#39;t have enough information to provide a list
</span></span><span class="line"><span class="cl">        # of methods
</span></span><span class="line"><span class="cl">        elif not hasattr(self.instance, &#39;_dispatch&#39;):
</span></span><span class="line"><span class="cl">            methods |= set(list_public_methods(self.instance))
</span></span><span class="line"><span class="cl">    return sorted(methods)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>将funcs字典的key返回的可迭代对象（类型是dict_keys）转换成set，方便进行集合的集合处理</li>
<li>None判断推荐<code>is not None</code>而不是 <code>if not self.instance:</code></li>
<li>集合求交集赋值可以使用 <code>|=</code>, 类似<code>+=1</code></li>
<li>集合没有sort方法，不像列表有<code>sorted(list)</code>和<code>list.sort()</code>两种方法。后者是原地排序，但是返回None；前者会重新生成一个列表。</li>
<li>动态获取属性这里使用<code>self.instance._listMethods()</code>，对比一下<code>getattr(instance, &quot;listMethods&quot;)()</code> , 前者更直观。</li>
</ul>
<p>系统帮助函数使用pydoc模块获取函数的帮助文档：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def system_methodHelp(self, method_name):
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    return pydoc.getdoc(method)
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是一个函数的文档实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def incr(self, age):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    长一岁
</span></span><span class="line"><span class="cl">    :type age: int
</span></span><span class="line"><span class="cl">    :rtype: int
</span></span><span class="line"><span class="cl">    :return 年龄+1
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    self.age = age
</span></span><span class="line"><span class="cl">    return self.age
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过pydoc.getdoc得到的帮助信息如下，这是自动生成api文档的基础。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">长一岁
</span></span><span class="line"><span class="cl">:type age: int
</span></span><span class="line"><span class="cl">:rtype: int
</span></span><span class="line"><span class="cl">:return 年龄+1
</span></span></code></pre></td></tr></table>
</div>
</div><p>_methodHelp展示了如何提供额外的rpc使用示例，帮助client理解API:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> def _methodHelp(self, method):
</span></span><span class="line"><span class="cl">        # this method must be present for system.methodHelp
</span></span><span class="line"><span class="cl">        # to work
</span></span><span class="line"><span class="cl">        if method == &#39;add&#39;:
</span></span><span class="line"><span class="cl">            return &#34;add(2,3) =&gt; 5&#34;
</span></span><span class="line"><span class="cl">        elif method == &#39;pow&#39;:
</span></span><span class="line"><span class="cl">            return &#34;pow(x, y[, z]) =&gt; number&#34;
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">            # By convention, return empty
</span></span><span class="line"><span class="cl">            # string if no help is available
</span></span><span class="line"><span class="cl">            return &#34;&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>_marshaled_dispatch处理最关键的rpc实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
</span></span><span class="line"><span class="cl">    try:
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">    except:
</span></span><span class="line"><span class="cl">        # report exception back to server
</span></span><span class="line"><span class="cl">        exc_type, exc_value, exc_tb = sys.exc_info()
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            ...
</span></span><span class="line"><span class="cl">        finally:
</span></span><span class="line"><span class="cl">            # Break reference cycle
</span></span><span class="line"><span class="cl">            exc_type = exc_value = exc_tb = None
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一部分在之前的文章[xmlrpc源码阅读]中有过介绍，就不再重复介绍。这次我们重点关注一下异常处理部分。请看示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def some(x, y):
</span></span><span class="line"><span class="cl">    z = x / y
</span></span><span class="line"><span class="cl">    return z
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">try:
</span></span><span class="line"><span class="cl">    some(1, 0)
</span></span><span class="line"><span class="cl">except:
</span></span><span class="line"><span class="cl">    exc_type, exc_value, exc_tb = sys.exc_info()
</span></span><span class="line"><span class="cl">    print(exc_type, exc_value)
</span></span><span class="line"><span class="cl">    print(repr(traceback.extract_tb(exc_tb)))
</span></span></code></pre></td></tr></table>
</div>
</div><p>从下面的日志输出可以看到，使用traceback可以得到异常的调用堆栈信息，这对定位bug非常有帮助：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;class &#39;ZeroDivisionError&#39;&gt; division by zero
</span></span><span class="line"><span class="cl">[&lt;FrameSummary file /Users/*/work/yuanmahui/python/ch18-rpc/sample.py, line 59 in test_exec&gt;, &lt;FrameSummary file /Users/*/work/yuanmahui/python/ch18-rpc/sample.py, line 55 in some&gt;]
</span></span><span class="line"><span class="cl">Traceback (most recent call last):
</span></span><span class="line"><span class="cl">  File &#34;/Users/yoo/work/yuanmahui/python/ch18-rpc/sample.py&#34;, line 59, in test_exec
</span></span><span class="line"><span class="cl">    some(1, 0)
</span></span><span class="line"><span class="cl">  File &#34;/Users/yoo/work/yuanmahui/python/ch18-rpc/sample.py&#34;, line 55, in some
</span></span><span class="line"><span class="cl">    z = x / y
</span></span><span class="line"><span class="cl">ZeroDivisionError: division by zero
</span></span></code></pre></td></tr></table>
</div>
</div><p>_dispatch同样在之前的文章[xmlrpc源码阅读]中有过详细介绍，这次关注一下函数参数的自动封箱与拆箱:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def _dispatch(self, method, params):
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    return func(*params)
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面代码显示了如何使用args传递参数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def some(a, b, c=2):
</span></span><span class="line"><span class="cl">    print(a, b, c)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def f(args):
</span></span><span class="line"><span class="cl">    some(*args)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def f2(*args):
</span></span><span class="line"><span class="cl">    some(*args)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 0 1 2
</span></span><span class="line"><span class="cl">f((0, 1))
</span></span><span class="line"><span class="cl">f((1, 2, 3))
</span></span><span class="line"><span class="cl"># a b c # 这样竟然也可以...
</span></span><span class="line"><span class="cl">f({&#34;a&#34;: 4, &#34;b&#34;: 5, &#34;c&#34;: 6})
</span></span><span class="line"><span class="cl">f2(*(1, 2, 3))
</span></span><span class="line"><span class="cl">f2(1, 2, 3)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>总结 <code>*args</code>在函数定义中，会自动把位置参数进行封箱(多个参数合并成一个元祖参数，就像用箱子封装一样)成元祖； <code>*args</code>在函数调用的时候，又自动把元祖参数拆箱成多个参数。</li>
</ul>
<h2 id="simplexmlrpcrequesthandler分析">SimpleXMLRPCRequestHandler分析</h2>
<p>SimpleXMLRPCRequestHandler继承自BaseHTTPRequestHandler。 encode_threshold定义了一个MTU推荐值，就是一个tcp包的在网络传输过程中的上限大小。如果超过则会拆分成多个IP包进行传输，这样会有多次网络传输，效率会变低。解决的办法就是超过MTU值的数据使用gzip压缩算法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#if not None, encode responses larger than this, if possible
</span></span><span class="line"><span class="cl">encode_threshold = 1400 #a common MTU
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if self.encode_threshold is not None:
</span></span><span class="line"><span class="cl">    if len(response) &gt; self.encode_threshold:
</span></span><span class="line"><span class="cl">        q = self.accept_encodings().get(&#34;gzip&#34;, 0)
</span></span><span class="line"><span class="cl">        if q:
</span></span><span class="line"><span class="cl">            try:
</span></span><span class="line"><span class="cl">                response = gzip_encode(response)
</span></span><span class="line"><span class="cl">                self.send_header(&#34;Content-Encoding&#34;, &#34;gzip&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>SimpleXMLRPCRequestHandler有多个类属性:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    wbufsize = -1
</span></span><span class="line"><span class="cl">    disable_nagle_algorithm = True
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>类属性如果希望被扩展，可以使用小写；如果不推荐扩展，可以使用大写，类似常量定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="c1"># bottle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">class</span><span class="w"> </span><span class="nf">BaseRequest</span><span class="p">(</span><span class="n">object</span><span class="p">):</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">#: Maximum size of memory buffer for :attr:`body` in bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">MEMFILE_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">102400</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">#: Maximum number pr GET or POST parameters per request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">MAX_PARAMS</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果希望提供常量值，又可以被扩展，可以参考下面的写法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># http.server
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DEFAULT_ERROR_CONTENT_TYPE = &#34;text/html;charset=utf-8&#34;
</span></span><span class="line"><span class="cl">DEFAULT_ERROR_MESSAGE = &#34;&#34;&#34;...&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class BaseHTTPRequestHandler(socketserver.StreamRequestHandler):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sys_version = &#34;Python/&#34; + sys.version.split()[0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    server_version = &#34;BaseHTTP/&#34; + __version__
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    error_message_format = DEFAULT_ERROR_MESSAGE
</span></span><span class="line"><span class="cl">    error_content_type = DEFAULT_ERROR_CONTENT_TYPE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    default_request_version = &#34;HTTP/0.9&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>http头上的Accept-Encoding可以使用下面的正则进行解析:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># a re to match a gzip Accept-Encoding
</span></span><span class="line"><span class="cl">aepattern = re.compile(r&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">                        \s* ([^\s;]+) \s*            #content-coding
</span></span><span class="line"><span class="cl">                        (;\s* q \s*=\s* ([0-9\.]+))? #q
</span></span><span class="line"><span class="cl">                        &#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def accept_encodings(self):
</span></span><span class="line"><span class="cl">    r = {}
</span></span><span class="line"><span class="cl">    ae = self.headers.get(&#34;Accept-Encoding&#34;, &#34;&#34;)
</span></span><span class="line"><span class="cl">    for e in ae.split(&#34;,&#34;):
</span></span><span class="line"><span class="cl">        match = self.aepattern.match(e)
</span></span><span class="line"><span class="cl">        if match:
</span></span><span class="line"><span class="cl">            v = match.group(3)
</span></span><span class="line"><span class="cl">            v = float(v) if v else 1.0
</span></span><span class="line"><span class="cl">            r[match.group(1)] = v
</span></span><span class="line"><span class="cl">    return r
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是一些常见的Accept-Encoding举例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Accept-Encoding: gzip
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Accept-Encoding: gzip, compress, br
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1
</span></span><span class="line"><span class="cl"># q 介于0和1之间，不存在则为1，数值表示优先级
</span></span></code></pre></td></tr></table>
</div>
</div><p>do_POST函数一样，查看一下500状态的处理:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-v" data-lang="v"><span class="line"><span class="cl"><span class="nv">except</span> <span class="nc">Exception</span> <span class="k">as</span> <span class="nv">e</span><span class="p">:</span> <span class="o">#</span> <span class="nc">This</span> <span class="nv">should</span> <span class="nv">only</span> <span class="nv">happen</span> <span class="k">if</span> <span class="nv">the</span> <span class="kn">module</span> <span class="k">is</span> <span class="nv">buggy</span>
</span></span><span class="line"><span class="cl">    <span class="nv">self</span><span class="p">.</span><span class="nf">send_response</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">#</span> <span class="nc">Send</span> <span class="nv">information</span> <span class="nv">about</span> <span class="nv">the</span> <span class="nv">exception</span> <span class="k">if</span> <span class="nv">requested</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">hasattr</span><span class="p">(</span><span class="nv">self</span><span class="p">.</span><span class="nv">server</span><span class="p">,</span> <span class="s1">&#39;_send_traceback_header&#39;</span><span class="p">)</span> <span class="nv">and</span> \
</span></span><span class="line"><span class="cl">            <span class="nv">self</span><span class="p">.</span><span class="nv">server</span><span class="p">.</span><span class="nl">_send_traceback_header</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nv">self</span><span class="p">.</span><span class="nf">send_header</span><span class="p">(</span><span class="s2">&#34;X-exception&#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nv">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nv">trace</span> <span class="o">=</span> <span class="nv">traceback</span><span class="p">.</span><span class="nf">format_exc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nv">trace</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nv">trace</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="s1">&#39;ASCII&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">),</span> <span class="s1">&#39;ASCII&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">self</span><span class="p">.</span><span class="nf">send_header</span><span class="p">(</span><span class="s2">&#34;X-traceback&#34;</span><span class="p">,</span> <span class="nv">trace</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>这里定义了<strong>X-exception</strong>和<strong>X-traceback</strong>两个特别的http头，一般来说使用<code>X-</code>前缀表示自定义的头，在django中会看到这种方式。</li>
</ul>
<p>decode_request_content函数处理请求数据，下面是调用方法和函数实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def do_POST(self):
</span></span><span class="line"><span class="cl">    data = self.decode_request_content(data)
</span></span><span class="line"><span class="cl">    if data is None:
</span></span><span class="line"><span class="cl">        return #response has been sent
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    self.send_response(200)
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    self.end_headers()
</span></span><span class="line"><span class="cl">    self.wfile.write(response)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def decode_request_content(self, data):
</span></span><span class="line"><span class="cl">    #support gzip encoding of request
</span></span><span class="line"><span class="cl">    encoding = self.headers.get(&#34;content-encoding&#34;, &#34;identity&#34;).lower()
</span></span><span class="line"><span class="cl">    if encoding == &#34;identity&#34;:
</span></span><span class="line"><span class="cl">        return data
</span></span><span class="line"><span class="cl">    if encoding == &#34;gzip&#34;:
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            return gzip_decode(data)
</span></span><span class="line"><span class="cl">        except NotImplementedError:
</span></span><span class="line"><span class="cl">            self.send_response(501, &#34;encoding %r not supported&#34; % encoding)
</span></span><span class="line"><span class="cl">        except ValueError:
</span></span><span class="line"><span class="cl">            self.send_response(400, &#34;error decoding gzip content&#34;)
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        self.send_response(501, &#34;encoding %r not supported&#34; % encoding)
</span></span><span class="line"><span class="cl">    self.send_header(&#34;Content-length&#34;, &#34;0&#34;)
</span></span><span class="line"><span class="cl">    self.end_headers()
</span></span></code></pre></td></tr></table>
</div>
</div><p>个人觉得，这个函数实现不太好。如果解析请求失败，异常处理header在另外的地方，导致逻辑结构不对等。我尝试修改一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">error_code, error_info = None, None
</span></span><span class="line"><span class="cl">if encoding == &#34;identity&#34;:
</span></span><span class="line"><span class="cl">        return 0, data
</span></span><span class="line"><span class="cl">if encoding == &#34;gzip&#34;:
</span></span><span class="line"><span class="cl">    try:
</span></span><span class="line"><span class="cl">        return 0, gzip_decode(data)
</span></span><span class="line"><span class="cl">    except NotImplementedError:
</span></span><span class="line"><span class="cl">        error_code, error_info = 501, &#34;encoding %r not supported&#34; % encoding
</span></span><span class="line"><span class="cl">    except ValueError:
</span></span><span class="line"><span class="cl">        error_code, error_info = 400, &#34;error decoding gzip content&#34;
</span></span><span class="line"><span class="cl">else:
</span></span><span class="line"><span class="cl">    error_code, error_info = 501, &#34;encoding %r not supported&#34; % encoding
</span></span><span class="line"><span class="cl">return error_code, error_info
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样关于header解析失败的逻辑在do_POST中实现，更统一。这里的error_code参考了golang的语法实现。大家觉得呢?欢迎在评论区留言点评。</p>
<p>log_request中使用了比较老式的调用父类方法的语法，而不是使用<code>super</code>关键字:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class BaseHTTPRequestHandler(socketserver.StreamRequestHandler):
</span></span><span class="line"><span class="cl">    def log_request(self, code=&#39;-&#39;, size=&#39;-&#39;):
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;Log an accepted request.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        This is called by send_response().
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        if isinstance(code, HTTPStatus):
</span></span><span class="line"><span class="cl">            code = code.value
</span></span><span class="line"><span class="cl">        self.log_message(&#39;&#34;%s&#34; %s %s&#39;,
</span></span><span class="line"><span class="cl">                         self.requestline, str(code), str(size))
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">class SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def log_request(self, code=&#39;-&#39;, size=&#39;-&#39;):
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;Selectively log an accepted request.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if self.server.logRequests:
</span></span><span class="line"><span class="cl">            BaseHTTPRequestHandler.log_request(self, code, size)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="simplexmlrpcserver-分析">SimpleXMLRPCServer 分析</h2>
<p>SimpleXMLRPCServer展示多类继承时候的父类初始化方法，不同的父类的初始化参数不一样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class SimpleXMLRPCServer(socketserver.TCPServer,
</span></span><span class="line"><span class="cl">                         SimpleXMLRPCDispatcher):
</span></span><span class="line"><span class="cl">     def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
</span></span><span class="line"><span class="cl">                 logRequests=True, allow_none=False, encoding=None,
</span></span><span class="line"><span class="cl">                 bind_and_activate=True, use_builtin_types=False):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)
</span></span><span class="line"><span class="cl">        socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="multipathxmlrpcserver--cgixmlrpcrequesthandler">MultiPathXMLRPCServer &amp;&amp; CGIXMLRPCRequestHandler</h2>
<p>MultiPathXMLRPCServer支持注册多个dispatcher实现，每个dispatcher支持不同的rpc路径，不像SimpleXMLRPCServer仅支持<code>/RPC2</code>，功能更强劲:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class MultiPathXMLRPCServer(SimpleXMLRPCServer):
</span></span><span class="line"><span class="cl">    def __init__(...):
</span></span><span class="line"><span class="cl">        self.dispatchers = {}
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    def add_dispatcher(self, path, dispatcher):
</span></span><span class="line"><span class="cl">        self.dispatchers[path] = dispatcher
</span></span><span class="line"><span class="cl">        return dispatcher
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        response = self.dispatchers[path]._marshaled_dispatch(
</span></span><span class="line"><span class="cl">               data, dispatch_method, path)
</span></span><span class="line"><span class="cl">        ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>CGIXMLRPCRequestHandler提供了一种CGI实现。CGI在之前的[python http 源码阅读]有过介绍，特点就是输入输出使用标准流，CGI现在用的较少，简单了解即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher)
</span></span><span class="line"><span class="cl">    def handle_xmlrpc(self, request_text):
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        sys.stdout.buffer.write(response)
</span></span><span class="line"><span class="cl">        sys.stdout.buffer.flush()
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    def handle_request(self, request_text=None):
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        request_text = sys.stdin.read(length)
</span></span><span class="line"><span class="cl">        ...
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="rpc-doc">rpc-doc</h2>
<p>ServerHTMLDoc, XMLRPCDocGenerator, DocXMLRPCRequestHandler和DocXMLRPCServer提供了更详细的RPC文档实现。文档对RPC服务来说非常重要，是RPC-client和RPC-server之间的重要规范，所以xmlrpc-server中用了大量篇幅来实现。不过，由于篇幅和时间原因，本文就不再进行详细分析其实现。</p>
<h2 id="小结">小结</h2>
<p>xmlrpc-server核心由SimpleXMLRPCDispatcher，SimpleXMLRPCRequestHandler 和SimpleXMLRPCServer三个类实现，分工非常明确。 SimpleXMLRPCServer实现一个http服务，SimpleXMLRPCRequestHandler用于处理http请求和响应，SimpleXMLRPCDispatcher实现xml-rpc服务。当然其中还有一个核心的地方是<code>dumps</code>和<code>loads</code>方法，负责在http请求和rpc请求之间互换，这部分在client中，也先略过了。分拆类后，扩展性也很强，MultiPathXMLRPCServer扩展SimpleXMLRPCServer，实现多路径支持；CGIXMLRPCRequestHandler扩展SimpleXMLRPCDispatcher实现cgi支持；DocXMLRPCRequestHandler扩展SimpleXMLRPCRequestHandler实现文档支持。</p>
<p>MultiPathXMLRPCServer是前端控制器模式的实现，MultiPathXMLRPCServer充当了Front Controller的角色，支持多个dispatcher；SimpleXMLRPCDispatcher是Dispatcher的角色；而业务注册RPC函数，比如ExampleService.getData函数就是View了。这样就不是只会单例模式这一种设计模式，或者是设计模式一看就懂，一用就抓瞎。</p>
<h2 id="小技巧">小技巧</h2>
<p>大家可以猜猜看，下图中的字符是什么?
<img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20210518134431.png" alt="!="></p>
<p>原创不易，欢迎加下面的微信和我互动交流，一起进阶:
<img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E7%99%BD%E8%89%B2%E7%89%88.png" alt="wx"></p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python</a></li>
<li><a href="https://stackoverflow.com/questions/664118/whats-the-difference-between-dict-and">https://stackoverflow.com/questions/664118/whats-the-difference-between-dict-and</a></li>
<li><a href="https://realpython.com/python-sets/">https://realpython.com/python-sets/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">shawn</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-05-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/rpc/">rpc</a>
          <a href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
          <a href="/tags/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/">阅读方法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/python/werkzeug-1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Werkzeug 源码阅读-上</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/python/pypy-1/">
            <span class="next-text nav-default">PyPy真的能让python比c还快？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '2021-05-20 23:13:57 \u002b0800 CST',
        title: '再聊我的源码阅读方法-xmlrpc源码慢读',
        link: decodeURI(location.href),
        desc: '之前介绍我的源码阅读方法，有粉丝朋友说很有帮助，认为是授人予鱼。这是过誉了，也让我很受鼓舞，这次带来另外一种阅读方法，希望对大家也有帮助。 在',
        owner: 'game404',
        repo: 'game404.github.io',
        oauth: {
          client_id: '28a86ccaa3184b49dfc4',
          client_secret: '15ab0f7c1445c0afb5e3d7a8995c89f2fd081eb7'
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:studyoo@foxmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/game404" class="iconfont icon-github" title="github"></a>
      <a href="https://juejin.im/user/593f44b8da2f60006736604e" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://game404.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>game404</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-137813525-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
