<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Celery 源码解析 - 4 - 游戏不存在</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="shawn" /><meta name="description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大" /><meta name="keywords" content="game, docker, kubernetes, python, go,  microservice" />






<meta name="generator" content="Hugo 0.54.0 with even 4.0.0" />
<meta name="google-site-verification" content="Qzk5S1WaeGv-bmDYA5rCo0HemniTpED_o5PAvmPp-yo" />


<link rel="canonical" href="https://game404.github.io/post/python/celery-4/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Celery 源码解析 - 4" />
<meta property="og:description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://game404.github.io/post/python/celery-4/" />
<meta property="article:published_time" content="2021-11-07T23:05:44&#43;08:00"/>
<meta property="article:modified_time" content="2021-11-07T23:05:44&#43;08:00"/>

<meta itemprop="name" content="Celery 源码解析 - 4">
<meta itemprop="description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大">


<meta itemprop="datePublished" content="2021-11-07T23:05:44&#43;08:00" />
<meta itemprop="dateModified" content="2021-11-07T23:05:44&#43;08:00" />
<meta itemprop="wordCount" content="5548">



<meta itemprop="keywords" content="celery,源码,算法," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Celery 源码解析 - 4"/>
<meta name="twitter:description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">游戏不存在</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">游戏不存在</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Celery 源码解析 - 4</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-07 </span>
        <div class="post-category">
            <a href="/categories/python/"> python </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#lru缓存淘汰算法">LRU缓存淘汰算法</a></li>
<li><a href="#令牌桶限流算法">令牌桶限流算法</a></li>
<li><a href="#round-robin调度算法">Round-Robin调度算法</a></li>
<li><a href="#lamportclock算法">LamportClock算法</a></li>
<li><a href="#laxboundedsemaphore有限信号量算法">LaxBoundedSemaphore有限信号量算法</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#小技巧">小技巧</a></li>
<li><a href="#参考链接">参考链接</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。</p>

<p>Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一整套操作此系统的工具。Celery 也是一款消息队列工具，可用于处理实时数据以及任务调度。</p>

<p>本文是是celery源码解析的第<strong>四</strong>篇，在前3篇里分别介绍了vine, py-amqp和kombu:</p>

<ol>
<li><a href="https://game404.github.io/post/python/celery-1/">神器 celery 源码解析- vine实现Promise功能</a></li>
<li><a href="https://game404.github.io/post/python/celery-2/">神器 celery 源码解析- py-amqp实现AMQP协议</a></li>
<li><a href="https://game404.github.io/post/python/celery-3/">神器 celery 源码解析- kombu，一个python实现的消息库</a></li>
</ol>

<p>kombu中的高级算法和各种排序算法不一样，都是解决一些具体的业务问题，非常有用。本文包括下面几个部分:</p>

<ul>
<li>LRU缓存淘汰算法</li>
<li>令牌桶限流算法</li>
<li>Round-Robin调度算法</li>
<li>LamportClock时间戳算法</li>
<li>LaxBoundedSemaphore有限信号量算法</li>
</ul>

<h2 id="lru缓存淘汰算法">LRU缓存淘汰算法</h2>

<p>缓存，顾名思义，就是将计算结果暂时存起来，以供后期使用，这样可以省去重复计算的工作。比如我们计算斐波那契数列的递归算法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma"># 根据定义递归求解
def fib(n):
    if n &lt;= 1: 
        return n
    return fib(n - 1) + fib(n - 2)</pre></td></tr></table>
</div>
</div>
<p>我们求n为5的数，展开数学公式大概如下(这里简化python函数fib名称为数学函数f):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma">f(5)=f(4)                    +f(3)
    =f(3)          +f(2)     +f(2)     +f(1)
    =f(2)     +f(1)+f(1)+f(0)+f(1)+f(0)+f(1)
    =f(1)+f(0)+f(1)+f(1)+f(0)+f(1)+f(0)+f(1)
    =5</pre></td></tr></table>
</div>
</div>
<p>根据数学公式，我们可以知道，在执行f(5)过程中，重复执行了5次f(1), 3次f(0)。要提高执行效率，就可以用到缓存。最简单的实现版本:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></pre></td>
<td class="lntd">
<pre class="chroma"># 根据定义递归求解
cache = {}
def fib_v1(n):
    if n in cache:
        return cache[n]
    if n &lt;= 1: 
        result = n
    else:
        result =  fib(n - 1) + fib(n - 2)
    cache[n] = result
    return result</pre></td></tr></table>
</div>
</div>
<p>这种实现方式有2个弊端，一个是依赖一个外部的cache变量，另一个是cache功能和fib函数绑定，还需要修改fib函数。我们可以通过一个装饰器实现这个cache，而不用改动fib函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></pre></td>
<td class="lntd">
<pre class="chroma">def cache_decorator(fun):
    _cache = {}

    def wrapper(*args, **kwargs):
        if args in _cache:
            return _cache[args]
        else:
            ret = fun(*args, **kwargs)
            _cache[args] = ret
            return ret

    return wrapper</pre></td></tr></table>
</div>
</div>
<p>使用的时候可以直接给fib函数添加上装饰器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">@cache_decorator
def fib(n):
    ...</pre></td></tr></table>
</div>
</div>
<p>这种缓存实现实现方式，还是会有问题：无法进行清理，内存会持续增长。编程中有一句话是: 命名和缓存失效是计算机科学里面最难应对的两件事。关于缓存淘汰有各种算法，请见参考链接，我这里重点介绍一下LRU和LFU。</p>

<ul>
<li>LRU(Least recently used)最早使用淘汰算法，核心特点是: <em>最早的数先淘汰</em></li>
<li>LFU(Least-frequently used)最少使用淘汰算法, 核心特点是: <em>最少的数先淘汰</em></li>
</ul>

<p>关于LRU，在我之前介绍<a href="https://game404.github.io/post/python/tinydb/">tinydb</a>时候有过介绍。其中的实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></pre></td>
<td class="lntd">
<pre class="chroma">class LRUCache(abc.MutableMapping, Generic[K, V]):
    def __init__(self, capacity=None):
        self.capacity = capacity  # 缓存容量
        self.cache = OrderedDict()  # 有序字典
    
    def get(self, key: K, default: D = None) -&gt; Optional[Union[V, D]]:
        value = self.cache.get(key)  # 从换成获取
        if value is not None:
            del self.cache[key]
            self.cache[key] = value  # 更新缓存顺序
            return value
        return default

    def set(self, key: K, value: V):
        if self.cache.get(key):
            del self.cache[key]  
            self.cache[key] = value # 更新缓存顺序及值
        else:
            self.cache[key] = value
            if self.capacity is not None and self.length &gt; self.capacity:
                self.cache.popitem(last=False)  # 淘汰最古老的数据</pre></td></tr></table>
</div>
</div>
<p>LRU的特点只要保持缓存数据是有序的, 我们甚至不需要自己实现，使用系统functools中的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma">from functools import lru_cache

@lru_cache()
def fib(n):
    ...</pre></td></tr></table>
</div>
</div>
<p>kombu中给我们提供了一个线程安全的版本, 主要实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></pre></td>
<td class="lntd">
<pre class="chroma"># kombu-5.0.0/kombu/utils/functional.py

class LRUCache(UserDict):
    &#34;&#34;&#34;LRU Cache implementation using a doubly linked list to track access.
    &#34;&#34;&#34;
    def __init__(self, limit=None):
        self.limit = limit
        self.mutex = threading.RLock()
        self.data = OrderedDict()
    
    def __getitem__(self, key):
        with self.mutex:
            value = self[key] = self.data.pop(key)
            return value
    
    def __setitem__(self, key, value):
        # remove least recently used key.
        with self.mutex:
            if self.limit and len(self.data) &gt;= self.limit:
                self.data.pop(next(iter(self.data)))
            self.data[key] = value
    ...</pre></td></tr></table>
</div>
</div>
<p>上面代码在设置和获取数据时候都先获取锁，然后再进行数据操作。</p>

<p>关于缓存使用，除了通过业务场景判断适用那种淘汰算法外，还可以使用具体的缓存命中率指标进行分析:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></pre></td>
<td class="lntd">
<pre class="chroma">def memoize(maxsize=None, keyfun=None, Cache=LRUCache):
    &#34;&#34;&#34;Decorator to cache function return value.&#34;&#34;&#34;
    def _memoize(fun):
        mutex = threading.Lock()
        cache = Cache(limit=maxsize)

        @wraps(fun)
        def _M(*args, **kwargs):
            if keyfun:
                key = keyfun(args, kwargs)
            else:
                key = args + (KEYWORD_MARK,) + tuple(sorted(kwargs.items()))
            try:
                with mutex:
                    value = cache[key]
            except KeyError:
                value = fun(*args, **kwargs)
                # 未命中需要执行函数
                _M.misses += 1
                with mutex:
                    cache[key] = value
            else:
                # 命中率增加
                _M.hits += 1
            return value

        def clear():
            &#34;&#34;&#34;Clear the cache and reset cache statistics.&#34;&#34;&#34;
            # 清理缓存及统计
            cache.clear()
            _M.hits = _M.misses = 0
        # 统计信息
        _M.hits = _M.misses = 0
        _M.clear = clear
        _M.original_func = fun
        return _M

    return _memoize</pre></td></tr></table>
</div>
</div>
<p>memoize的实现并不复杂，增加了hits/misses数据，可以统计分析缓存的命中率，帮助正确使用LRU缓存。还添加了clear接口，可以在需要的时候对缓存直接进行清理。</p>

<blockquote>
<p>注意memoize使用了一个锁，在LRUCache还是使用了一个锁，这个锁的使用，我们以后再讲。</p>
</blockquote>

<h2 id="令牌桶限流算法">令牌桶限流算法</h2>

<p>限流是指在系统面临高并发、大流量请求的情况下，限制新的流量对系统的访问，从而保证系统服务的安全性。常用的限流算法有计数器、漏斗算法和令牌桶算法。其中计数器算法又分固定窗口算法、滑动窗口算法，后者我们在TCP协议中经常会碰到。</p>

<p>算法中存在一个令牌桶，以恒定的速率向*令牌*桶中放入令牌。当请求来时，会首先到令牌桶中去拿令牌，如果拿到了令牌，则该请求会被处理，并消耗掉令牌；如果拿不到令牌，则该请求会被丢弃。当然令牌桶也有一定的*容量*，如果满了令牌就无法放进去了，这样算法就有限流作用。又因为令牌产生的速率是很定的，如果消费速率较低，桶里会额外缓存一部分令牌，用于应对流量突发时候的消耗。下面是算法的示意图:</p>

<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20211107203145.png" alt="Token bucket Diagram" /></p>

<p>我们具体看看kombu中提供的实现。TokenBucket类:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></pre></td>
<td class="lntd">
<pre class="chroma">class TokenBucket:
    #: The rate in tokens/second that the bucket will be refilled.
    fill_rate = None

    #: Maximum number of tokens in the bucket.
    capacity = 1

    #: Timestamp of the last time a token was taken out of the bucket.
    timestamp = None

    def __init__(self, fill_rate, capacity=1):
        # 容量上限
        self.capacity = float(capacity)
        # 剩余令牌数，初始等于容量上限
        self._tokens = capacity
        # 填充率
        self.fill_rate = float(fill_rate)
        self.timestamp = monotonic()
        # 数据容器
        self.contents = deque()

    def add(self, item):
        self.contents.append(item)

    def pop(self):
        # 先进先出
        return self.contents.popleft()</pre></td></tr></table>
</div>
</div>
<p>代码包括:
* 令牌速率fill_rate
* 桶的容量上限
* 一个时间戳
* 剩余令牌数
* 算法提供了一个基于双端队列的数据容器，可以对容器进行先进先出操作</p>

<p>令牌桶是否可用的判断:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></pre></td>
<td class="lntd">
<pre class="chroma">def can_consume(self, tokens=1):
    &#34;&#34;&#34;Check if one or more tokens can be consumed.

    Returns:
        bool: true if the number of tokens can be consumed
            from the bucket.  If they can be consumed, a call will also
            consume the requested number of tokens from the bucket.
            Calls will only consume `tokens` (the number requested)
            or zero tokens -- it will never consume a partial number
            of tokens.
    &#34;&#34;&#34;
    if tokens &lt;= self._get_tokens():
        # 消费n个令牌
        self._tokens -= tokens
        return True
    return False

def _get_tokens(self):
    if self._tokens &lt; self.capacity:
        # 记录当前时间
        now = monotonic()
        # 计算已经流失的令牌数量
        delta = self.fill_rate * (now - self.timestamp)
        # 更新容量上限或者剩余令牌和流失数量之和
        self._tokens = min(self.capacity, self._tokens + delta)
        self.timestamp = now
    return self._tokens</pre></td></tr></table>
</div>
</div>
<p>我们可以看到，算法在进行令牌消费判断的同时，还会对桶的剩余流量进行自校正，很巧妙。</p>

<p>TokenBucket的使用在ConsumerMixin的run方法中。创建了一个速率为1的令牌桶，然后持续的进行消费。如果有令牌则消费消费者上的消息；如果没有令牌则进行休眠</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></pre></td>
<td class="lntd">
<pre class="chroma">#ch23-celery/kombu-5.0.0/kombu/mixins.py:240

class ConsumerMixin:

    def run(self, _tokens=1, **kwargs):
        restart_limit = TokenBucket(1)
        ...
        # 无限循环
        while not self.should_stop:
            try:
                # 有令牌消费
                if restart_limit.can_consume(_tokens):  # pragma: no cover
                    for _ in self.consume(limit=None, **kwargs):
                        pass
                else:
                    # 没浪费休眠
                    sleep(restart_limit.expected_time(_tokens))
            except errors:
                ...</pre></td></tr></table>
</div>
</div>
<p>其中的休眠时间，是由令牌桶根据期望值计算得来:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></pre></td>
<td class="lntd">
<pre class="chroma">def expected_time(self, tokens=1):
    &#34;&#34;&#34;Return estimated time of token availability.

    Returns:
        float: the time in seconds.
    &#34;&#34;&#34;
    _tokens = self._get_tokens()
    tokens = max(tokens, _tokens)
    return (tokens - _tokens) / self.fill_rate</pre></td></tr></table>
</div>
</div>
<h2 id="round-robin调度算法">Round-Robin调度算法</h2>

<p>Round-Robin调度算法，最常见的大概是在nginx。Round-Robin方式可让nginx将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载，循环往复。在kombu中也提供了几种类似的调度算法:
* 轮询调度
* 公平调度</p>

<p>我们先看Round-Robin方式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></pre></td>
<td class="lntd">
<pre class="chroma">class round_robin_cycle:
    &#34;&#34;&#34;Iterator that cycles between items in round-robin.&#34;&#34;&#34;
    &#34;&#34;&#34;轮询调度算法&#34;&#34;&#34;

    def __init__(self, it=None):
        self.items = it if it is not None else []

    def update(self, it):
        &#34;&#34;&#34;Update items from iterable.&#34;&#34;&#34;
        &#34;&#34;&#34;更新列表&#34;&#34;&#34;
        self.items[:] = it

    def consume(self, n):
        &#34;&#34;&#34;Consume n items.&#34;&#34;&#34;
        &#34;&#34;&#34;消费n个元素&#34;&#34;&#34;
        return self.items[:n]

    def rotate(self, last_used):
        &#34;&#34;&#34;Move most recently used item to end of list.&#34;&#34;&#34;
        &#34;&#34;&#34;旋转:把最后一个元素放到列表某尾&#34;&#34;&#34;
        items = self.items
        try:
            items.append(items.pop(items.index(last_used)))
        except ValueError:
            pass
        return last_used</pre></td></tr></table>
</div>
</div>
<p>算法实现很简单，就是一个有序队列，可以每次消费前n个有序元素，并且可以将最近使用的元素旋转到队尾。下面是旋转的单元测试:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></pre></td>
<td class="lntd">
<pre class="chroma">def test_round_robin_cycle():
    it = cycle_by_name(&#39;round_robin&#39;)([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])
    assert it.consume(3) == [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
    it.rotate(&#39;B&#39;)
    assert it.consume(3) == [&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]
    it.rotate(&#39;A&#39;)
    assert it.consume(3) == [&#39;C&#39;, &#39;B&#39;, &#39;A&#39;]
    it.rotate(&#39;A&#39;)
    assert it.consume(3) == [&#39;C&#39;, &#39;B&#39;, &#39;A&#39;]
    it.rotate(&#39;C&#39;)
    assert it.consume(3) == [&#39;B&#39;, &#39;A&#39;, &#39;C&#39;]</pre></td></tr></table>
</div>
</div>
<p>还有一种公平循环的调度算法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></pre></td>
<td class="lntd">
<pre class="chroma">class FairCycle:
    &#34;&#34;&#34;Cycle between resources.

    Consume from a set of resources, where each resource gets
    an equal chance to be consumed from.

    Arguments:
        fun (Callable): Callback to call.
        resources (Sequence[Any]): List of resources.
        predicate (type): Exception predicate.
    &#34;&#34;&#34;
    
    def __init__(self, fun, resources, predicate=Exception):
        self.fun = fun
        self.resources = resources
        self.predicate = predicate
        #  初始位置
        self.pos = 0</pre></td></tr></table>
</div>
</div>
<p>FairCycle是一种资源之间公平循环的调度算法, 构造函数中:
* 利用资源的函数
* 多个资源的集合</p>

<p>使用的方式是使用get方法传入回调:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></pre></td>
<td class="lntd">
<pre class="chroma">def _next(self):
    while 1:
        try:
            resource = self.resources[self.pos]
            # 位置加1
            self.pos += 1
            return resource
        except IndexError:
            # 到尾部后，重置位置
            self.pos = 0
            if not self.resources:
                raise self.predicate()

def get(self, callback, **kwargs):
    &#34;&#34;&#34;Get from next resource.&#34;&#34;&#34;
    # 无限重试
    for tried in count(0):  # for infinity
        # 获取资源
        resource = self._next()
        try:
            # 利用资源
            return self.fun(resource, callback, **kwargs)
        except self.predicate:
            # reraise when retries exchausted.
            # 容错上限
            if tried &gt;= len(self.resources) - 1:
                raise</pre></td></tr></table>
</div>
</div>
<p>调度主要体现再获取资源的next函数上，没次获取资源后位置标志进行后移，到尾部后在重置到0，继续下一轮循环。算法还可以对资源进行容错，也就是如果获取到的资源无法正常使用，还可以尝试使用下一个资源进行重试。</p>

<h2 id="lamportclock算法">LamportClock算法</h2>

<p>兰波特时间戳算法(LamportClock)，使用逻辑时间戳作为值的版本以允许跨服务器对值进行排序，是解决分布式系统时间一致的重要算法。</p>

<p>服务器上的系统时间，使用物理的晶体振荡测量，会有不准的情况。我们会经常遇到服务器或者快或者慢的情况，一般使用NTP服务，来和互联网上的某个时间源进行同步。如果本地时间提前了，进行联网校时后，会出现本地时间倒退的问题。而对于两台不同的服务器上，要进行时间统一，就更不能使用系统时间。</p>

<p>兰波特时间戳算法，原理如下:
* 维护一个数字来表示时间戳，并且在每个集群节点都维护一个 Lamport 时钟的实例。
* 如果事件在节点内发生，时间戳加1
* 事件要发送到远端，则在消息总带上时间戳
* 接收到远端的消息，时间戳 = Max(本地时间戳，消息中的时间戳) + 1（进行校正跳跃）</p>

<p>这个过程，可以看下面的图示:</p>

<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20211107221638.png" alt="" /></p>

<p>从图中可以看到下面两点:
* 对于每个节点的事件时间，都是递增有序的，比如A是[4,5,7,10], B节点是[2,3,4,6,7], C节点是[1,5,6,8,9]
* 时间戳不是全局唯一，不同节点之间会存在序号重复，比如4号消息在A和B节点都存在，5号消息在A和C节点存在</p>

<p>了解算法的场景和原理后，我们再来看算法的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></pre></td>
<td class="lntd">
<pre class="chroma">class LamportClock:
    #: The clocks current value.
    value = 0

    def __init__(self, initial_value=0, Lock=Lock):
        self.value = initial_value
        self.mutex = Lock()

    def adjust(self, other):
        with self.mutex:
            value = self.value = max(self.value, other) + 1
            return value

    def forward(self):
        with self.mutex:
            self.value += 1
            return self.value</pre></td></tr></table>
</div>
</div>
<p>算法的实现其实非常简单，就是转发的时候时间戳+1；收到消息后进行校正，这个过程中使用线程锁，保证本地的有序。</p>

<h2 id="laxboundedsemaphore有限信号量算法">LaxBoundedSemaphore有限信号量算法</h2>

<p>前面讲的几种算法，都是基于线程锁实现。使用锁会降低效率，如果在协程中，可以使用无锁的方案，会更高效。kombu的LaxBoundedSemaphore实现，可以作为一种参考。</p>

<p>我们先看使用示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></pre></td>
<td class="lntd">
<pre class="chroma"> &gt;&gt;&gt; from future import print_statement as printf
# ^ ignore: just fooling stupid pyflakes

&gt;&gt;&gt; x = LaxBoundedSemaphore(2)

&gt;&gt;&gt; x.acquire(printf, &#39;HELLO 1&#39;)
HELLO 1

&gt;&gt;&gt; x.acquire(printf, &#39;HELLO 2&#39;)
HELLO 2

&gt;&gt;&gt; x.acquire(printf, &#39;HELLO 3&#39;)
&gt;&gt;&gt; x._waiters   # private, do not access directly
[print, (&#39;HELLO 3&#39;,)]

&gt;&gt;&gt; x.release()
HELLO 3</pre></td></tr></table>
</div>
</div>
<p>示例展示了几步:
1. 创建一个大小为2的LaxBoundedSemaphore信号量
2. 申请信号，并且执行print函数，可以立即执行
3. 继续申请信号执行print函数，也可以立即执行
4. 再申请信号执行print函数，这时候由于信号超标，函数不会立即执行
5. 手工释放信号量，最后一次申请的print函数自动执行</p>

<p>下面是具体的实现，LaxBoundedSemaphore的构造函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></pre></td>
<td class="lntd">
<pre class="chroma">class LaxBoundedSemaphore:
    def __init__(self, value):
        # 信号容量
        self.initial_value = self.value = value
        # 使用双端队列，FIFO
        self._waiting = deque()
        self._add_waiter = self._waiting.append
        self._pop_waiter = self._waiting.popleft</pre></td></tr></table>
</div>
</div>
<p>申请执行回调函数，会进行信号判断，信号充足会执行行回调并消减一次信号量；信号量不足则将函数及参数放入代办的队列:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></pre></td>
<td class="lntd">
<pre class="chroma">def acquire(self, callback, *partial_args, **partial_kwargs):
    &#34;&#34;&#34;Acquire semaphore.

    This will immediately apply ``callback`` if
    the resource is available, otherwise the callback is suspended
    until the semaphore is released.

    Arguments:
        callback (Callable): The callback to apply.
        *partial_args (Any): partial arguments to callback.
    &#34;&#34;&#34;
    value = self.value
    if value &lt;= 0:
        # 容量不够的时候先暂存执行函数，并不更改可用数量
        self._add_waiter((callback, partial_args, partial_kwargs))
        return False
    else:
        # 可用数量-1
        self.value = max(value - 1, 0)
        # 直接执行函数
        callback(*partial_args, **partial_kwargs)
        return True</pre></td></tr></table>
</div>
</div>
<p>使用release时候会取出头部的代办函数，并进行执行，此时信号量不增不减。如果代办全部执行完成后，则逐步恢复信号量到默认值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></pre></td>
<td class="lntd">
<pre class="chroma">def release(self):
    &#34;&#34;&#34;Release semaphore.

    Note:
        If there are any waiters this will apply the first waiter
        that is waiting for the resource (FIFO order).
    &#34;&#34;&#34;
    try:
        waiter, args, kwargs = self._pop_waiter()
    except IndexError:
        # 无缓存则只增加可用数量
        self.value = min(self.value + 1, self.initial_value)
    else:
        # 有缓存则执行第一个缓存，可用数量不变还是小于0
        waiter(*args, **kwargs)</pre></td></tr></table>
</div>
</div>
<h2 id="小结">小结</h2>

<p>本篇文章，我们学习了5种实用的业务算法。LRU缓存淘汰算法，可以对缓存中最早的数据进行淘汰。令牌桶限流算法，可以协助进行服务流量限流，较好的保护后端服务，避免突发流量的到时的崩溃。Round-Robin调度算法，可以进行负载的均衡，保障资源的平衡使用。LamportClock时间戳算法，可以在分布式系统中，进行不同服务之间的有序时间戳同步。LaxBoundedSemaphore有限信号量算法，是一种无锁算法，可高效的提供资源使用控制。</p>

<h2 id="小技巧">小技巧</h2>

<p>kombu中提供了一个自动重试算法，可以作为重试算法的模版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></pre></td>
<td class="lntd">
<pre class="chroma"># kombu-5.0.0/kombu/utils/functional.py

def retry_over_time(fun, catch, args=None, kwargs=None, errback=None,
                    max_retries=None, interval_start=2, interval_step=2,
                    interval_max=30, callback=None, timeout=None):
    kwargs = {} if not kwargs else kwargs
    args = [] if not args else args
    interval_range = fxrange(interval_start,
                             interval_max + interval_start,
                             interval_step, repeatlast=True)
    # 超时时间
    end = time() + timeout if timeout else None
    for retries in count():
        try:
            return fun(*args, **kwargs)
        except catch as exc:
            # 超过次数
            if max_retries is not None and retries &gt;= max_retries:
                raise
            # 超过时间
            if end and time() &gt; end:
                raise
            ...
            # 休眠
            sleep(1.0)</pre></td></tr></table>
</div>
</div>
<p>从模版可以看到重试时候使用次数和超时时间两个维度进行跳出(不可能无限重试):
* 使用count()进行无限循环
* 使用time()进行超时限定
* 使用max_retries容错上限次数限定
* 每次错误后，都休眠一段时间，给被调用方机会，提高下一次成功的概率。</p>

<blockquote>
<p>实际上关于休眠时间，也有一些更复杂的算法，比如线性递增之类，这里使用了固定间隔的休眠</p>
</blockquote>

<!--
```
def _LeftBlank(obj, method):
    return NotImplementedError(
        'Transport {0.__module__}.{0.__name__} does not implement {1}'.format(
            obj.__class__, method))

def close_connection(self, connection):
    raise _LeftBlank(self, 'close_connection')
```
-->

<h2 id="参考链接">参考链接</h2>

<ul>
<li>缓存淘汰算法 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU">https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU</a>)</li>
<li>令牌桶算法 <a href="https://en.wikipedia.org/wiki/Token_Bucket">https://en.wikipedia.org/wiki/Token_Bucket</a></li>
<li>what-is-token-bucket-and-leaky-bucket-algorithms <a href="https://hansliu.com/posts/2020/11/what-is-token-bucket-and-leaky-bucket-algorithms.html">https://hansliu.com/posts/2020/11/what-is-token-bucket-and-leaky-bucket-algorithms.html</a></li>
<li>波特时间戳算法 <a href="https://en.wikipedia.org/wiki/Lamport_timestamps">https://en.wikipedia.org/wiki/Lamport_timestamps</a></li>
<li>lamport面包店算法简介 <a href="https://segmentfault.com/a/1190000011066299">https://segmentfault.com/a/1190000011066299</a></li>
<li><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html">https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">shawn</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-11-07
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/celery/">celery</a>
          <a href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
          <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/python/celery-5/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Celery 源码解析 - 5</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/service-lang/">
            <span class="next-text nav-default">谁是虽好的语言 ？- 语言选型闲聊（上）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '2021-11-07 23:05:44 \x2b0800 CST',
        title: 'Celery 源码解析 - 4',
        link: decodeURI(location.href),
        desc: '本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大',
        owner: 'game404',
        repo: 'game404.github.io',
        oauth: {
          client_id: '28a86ccaa3184b49dfc4',
          client_secret: '15ab0f7c1445c0afb5e3d7a8995c89f2fd081eb7'
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:studyoo@foxmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/game404" class="iconfont icon-github" title="github"></a>
      <a href="https://juejin.im/user/593f44b8da2f60006736604e" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://game404.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">game404</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-137813525-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
