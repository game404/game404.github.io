<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Celery 源码解析 - 4 - 游戏不存在</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="shawn" /><meta name="description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大" /><meta name="keywords" content="game, docker, kubernetes, python, go,  microservice" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://game404.github.io/post/python/celery-4/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Celery 源码解析 - 4" />
<meta property="og:description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://game404.github.io/post/python/celery-4/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-07T23:05:44+08:00" />
<meta property="article:modified_time" content="2021-11-07T23:05:44+08:00" />

<meta itemprop="name" content="Celery 源码解析 - 4">
<meta itemprop="description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大"><meta itemprop="datePublished" content="2021-11-07T23:05:44+08:00" />
<meta itemprop="dateModified" content="2021-11-07T23:05:44+08:00" />
<meta itemprop="wordCount" content="5520">
<meta itemprop="keywords" content="celery,源码,算法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Celery 源码解析 - 4"/>
<meta name="twitter:description" content="本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">游戏不存在</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">游戏不存在</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Celery 源码解析 - 4</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-07 </span>
        <div class="post-category">
            <a href="/categories/python/"> python </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#lru缓存淘汰算法">LRU缓存淘汰算法</a></li>
    <li><a href="#令牌桶限流算法">令牌桶限流算法</a></li>
    <li><a href="#round-robin调度算法">Round-Robin调度算法</a></li>
    <li><a href="#lamportclock算法">LamportClock算法</a></li>
    <li><a href="#laxboundedsemaphore有限信号量算法">LaxBoundedSemaphore有限信号量算法</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#小技巧">小技巧</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。</p>
<p>Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一整套操作此系统的工具。Celery 也是一款消息队列工具，可用于处理实时数据以及任务调度。</p>
<p>本文是是celery源码解析的第<strong>四</strong>篇，在前3篇里分别介绍了vine, py-amqp和kombu:</p>
<ol>
<li><a href="https://game404.github.io/post/python/celery-1/">神器 celery 源码解析- vine实现Promise功能</a></li>
<li><a href="https://game404.github.io/post/python/celery-2/">神器 celery 源码解析- py-amqp实现AMQP协议</a></li>
<li><a href="https://game404.github.io/post/python/celery-3/">神器 celery 源码解析- kombu，一个python实现的消息库</a></li>
</ol>
<p>kombu中的高级算法和各种排序算法不一样，都是解决一些具体的业务问题，非常有用。本文包括下面几个部分:</p>
<ul>
<li>LRU缓存淘汰算法</li>
<li>令牌桶限流算法</li>
<li>Round-Robin调度算法</li>
<li>LamportClock时间戳算法</li>
<li>LaxBoundedSemaphore有限信号量算法</li>
</ul>
<h2 id="lru缓存淘汰算法">LRU缓存淘汰算法</h2>
<p>缓存，顾名思义，就是将计算结果暂时存起来，以供后期使用，这样可以省去重复计算的工作。比如我们计算斐波那契数列的递归算法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 根据定义递归求解
</span></span><span class="line"><span class="cl">def fib(n):
</span></span><span class="line"><span class="cl">    if n &lt;= 1: 
</span></span><span class="line"><span class="cl">        return n
</span></span><span class="line"><span class="cl">    return fib(n - 1) + fib(n - 2)
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们求n为5的数，展开数学公式大概如下(这里简化python函数fib名称为数学函数f):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">f(5)=f(4)                    +f(3)
</span></span><span class="line"><span class="cl">    =f(3)          +f(2)     +f(2)     +f(1)
</span></span><span class="line"><span class="cl">    =f(2)     +f(1)+f(1)+f(0)+f(1)+f(0)+f(1)
</span></span><span class="line"><span class="cl">    =f(1)+f(0)+f(1)+f(1)+f(0)+f(1)+f(0)+f(1)
</span></span><span class="line"><span class="cl">    =5
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据数学公式，我们可以知道，在执行f(5)过程中，重复执行了5次f(1), 3次f(0)。要提高执行效率，就可以用到缓存。最简单的实现版本:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 根据定义递归求解
</span></span><span class="line"><span class="cl">cache = {}
</span></span><span class="line"><span class="cl">def fib_v1(n):
</span></span><span class="line"><span class="cl">    if n in cache:
</span></span><span class="line"><span class="cl">        return cache[n]
</span></span><span class="line"><span class="cl">    if n &lt;= 1: 
</span></span><span class="line"><span class="cl">        result = n
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        result =  fib(n - 1) + fib(n - 2)
</span></span><span class="line"><span class="cl">    cache[n] = result
</span></span><span class="line"><span class="cl">    return result
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种实现方式有2个弊端，一个是依赖一个外部的cache变量，另一个是cache功能和fib函数绑定，还需要修改fib函数。我们可以通过一个装饰器实现这个cache，而不用改动fib函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def cache_decorator(fun):
</span></span><span class="line"><span class="cl">    _cache = {}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def wrapper(*args, **kwargs):
</span></span><span class="line"><span class="cl">        if args in _cache:
</span></span><span class="line"><span class="cl">            return _cache[args]
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">            ret = fun(*args, **kwargs)
</span></span><span class="line"><span class="cl">            _cache[args] = ret
</span></span><span class="line"><span class="cl">            return ret
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return wrapper
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用的时候可以直接给fib函数添加上装饰器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@cache_decorator
</span></span><span class="line"><span class="cl">def fib(n):
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种缓存实现实现方式，还是会有问题：无法进行清理，内存会持续增长。编程中有一句话是: 命名和缓存失效是计算机科学里面最难应对的两件事。关于缓存淘汰有各种算法，请见参考链接，我这里重点介绍一下LRU和LFU。</p>
<ul>
<li>LRU(Least recently used)最早使用淘汰算法，核心特点是: <em>最早的数先淘汰</em></li>
<li>LFU(Least-frequently used)最少使用淘汰算法, 核心特点是: <em>最少的数先淘汰</em></li>
</ul>
<p>关于LRU，在我之前介绍<a href="https://game404.github.io/post/python/tinydb/">tinydb</a>时候有过介绍。其中的实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class LRUCache(abc.MutableMapping, Generic[K, V]):
</span></span><span class="line"><span class="cl">    def __init__(self, capacity=None):
</span></span><span class="line"><span class="cl">        self.capacity = capacity  # 缓存容量
</span></span><span class="line"><span class="cl">        self.cache = OrderedDict()  # 有序字典
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    def get(self, key: K, default: D = None) -&gt; Optional[Union[V, D]]:
</span></span><span class="line"><span class="cl">        value = self.cache.get(key)  # 从换成获取
</span></span><span class="line"><span class="cl">        if value is not None:
</span></span><span class="line"><span class="cl">            del self.cache[key]
</span></span><span class="line"><span class="cl">            self.cache[key] = value  # 更新缓存顺序
</span></span><span class="line"><span class="cl">            return value
</span></span><span class="line"><span class="cl">        return default
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def set(self, key: K, value: V):
</span></span><span class="line"><span class="cl">        if self.cache.get(key):
</span></span><span class="line"><span class="cl">            del self.cache[key]  
</span></span><span class="line"><span class="cl">            self.cache[key] = value # 更新缓存顺序及值
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">            self.cache[key] = value
</span></span><span class="line"><span class="cl">            if self.capacity is not None and self.length &gt; self.capacity:
</span></span><span class="line"><span class="cl">                self.cache.popitem(last=False)  # 淘汰最古老的数据
</span></span></code></pre></td></tr></table>
</div>
</div><p>LRU的特点只要保持缓存数据是有序的, 我们甚至不需要自己实现，使用系统functools中的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from functools import lru_cache
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@lru_cache()
</span></span><span class="line"><span class="cl">def fib(n):
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>kombu中给我们提供了一个线程安全的版本, 主要实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kombu-5.0.0/kombu/utils/functional.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LRUCache(UserDict):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;LRU Cache implementation using a doubly linked list to track access.
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    def __init__(self, limit=None):
</span></span><span class="line"><span class="cl">        self.limit = limit
</span></span><span class="line"><span class="cl">        self.mutex = threading.RLock()
</span></span><span class="line"><span class="cl">        self.data = OrderedDict()
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    def __getitem__(self, key):
</span></span><span class="line"><span class="cl">        with self.mutex:
</span></span><span class="line"><span class="cl">            value = self[key] = self.data.pop(key)
</span></span><span class="line"><span class="cl">            return value
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    def __setitem__(self, key, value):
</span></span><span class="line"><span class="cl">        # remove least recently used key.
</span></span><span class="line"><span class="cl">        with self.mutex:
</span></span><span class="line"><span class="cl">            if self.limit and len(self.data) &gt;= self.limit:
</span></span><span class="line"><span class="cl">                self.data.pop(next(iter(self.data)))
</span></span><span class="line"><span class="cl">            self.data[key] = value
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码在设置和获取数据时候都先获取锁，然后再进行数据操作。</p>
<p>关于缓存使用，除了通过业务场景判断适用那种淘汰算法外，还可以使用具体的缓存命中率指标进行分析:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def memoize(maxsize=None, keyfun=None, Cache=LRUCache):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Decorator to cache function return value.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    def _memoize(fun):
</span></span><span class="line"><span class="cl">        mutex = threading.Lock()
</span></span><span class="line"><span class="cl">        cache = Cache(limit=maxsize)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        @wraps(fun)
</span></span><span class="line"><span class="cl">        def _M(*args, **kwargs):
</span></span><span class="line"><span class="cl">            if keyfun:
</span></span><span class="line"><span class="cl">                key = keyfun(args, kwargs)
</span></span><span class="line"><span class="cl">            else:
</span></span><span class="line"><span class="cl">                key = args + (KEYWORD_MARK,) + tuple(sorted(kwargs.items()))
</span></span><span class="line"><span class="cl">            try:
</span></span><span class="line"><span class="cl">                with mutex:
</span></span><span class="line"><span class="cl">                    value = cache[key]
</span></span><span class="line"><span class="cl">            except KeyError:
</span></span><span class="line"><span class="cl">                value = fun(*args, **kwargs)
</span></span><span class="line"><span class="cl">                # 未命中需要执行函数
</span></span><span class="line"><span class="cl">                _M.misses += 1
</span></span><span class="line"><span class="cl">                with mutex:
</span></span><span class="line"><span class="cl">                    cache[key] = value
</span></span><span class="line"><span class="cl">            else:
</span></span><span class="line"><span class="cl">                # 命中率增加
</span></span><span class="line"><span class="cl">                _M.hits += 1
</span></span><span class="line"><span class="cl">            return value
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        def clear():
</span></span><span class="line"><span class="cl">            &#34;&#34;&#34;Clear the cache and reset cache statistics.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">            # 清理缓存及统计
</span></span><span class="line"><span class="cl">            cache.clear()
</span></span><span class="line"><span class="cl">            _M.hits = _M.misses = 0
</span></span><span class="line"><span class="cl">        # 统计信息
</span></span><span class="line"><span class="cl">        _M.hits = _M.misses = 0
</span></span><span class="line"><span class="cl">        _M.clear = clear
</span></span><span class="line"><span class="cl">        _M.original_func = fun
</span></span><span class="line"><span class="cl">        return _M
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return _memoize
</span></span></code></pre></td></tr></table>
</div>
</div><p>memoize的实现并不复杂，增加了hits/misses数据，可以统计分析缓存的命中率，帮助正确使用LRU缓存。还添加了clear接口，可以在需要的时候对缓存直接进行清理。</p>
<blockquote>
<p>注意memoize使用了一个锁，在LRUCache还是使用了一个锁，这个锁的使用，我们以后再讲。</p>
</blockquote>
<h2 id="令牌桶限流算法">令牌桶限流算法</h2>
<p>限流是指在系统面临高并发、大流量请求的情况下，限制新的流量对系统的访问，从而保证系统服务的安全性。常用的限流算法有计数器、漏斗算法和令牌桶算法。其中计数器算法又分固定窗口算法、滑动窗口算法，后者我们在TCP协议中经常会碰到。</p>
<p>算法中存在一个令牌桶，以恒定的速率向<em>令牌</em>桶中放入令牌。当请求来时，会首先到令牌桶中去拿令牌，如果拿到了令牌，则该请求会被处理，并消耗掉令牌；如果拿不到令牌，则该请求会被丢弃。当然令牌桶也有一定的<em>容量</em>，如果满了令牌就无法放进去了，这样算法就有限流作用。又因为令牌产生的速率是很定的，如果消费速率较低，桶里会额外缓存一部分令牌，用于应对流量突发时候的消耗。下面是算法的示意图:</p>
<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20211107203145.png" alt="Token bucket Diagram"></p>
<p>我们具体看看kombu中提供的实现。TokenBucket类:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class TokenBucket:
</span></span><span class="line"><span class="cl">    #: The rate in tokens/second that the bucket will be refilled.
</span></span><span class="line"><span class="cl">    fill_rate = None
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    #: Maximum number of tokens in the bucket.
</span></span><span class="line"><span class="cl">    capacity = 1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    #: Timestamp of the last time a token was taken out of the bucket.
</span></span><span class="line"><span class="cl">    timestamp = None
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def __init__(self, fill_rate, capacity=1):
</span></span><span class="line"><span class="cl">        # 容量上限
</span></span><span class="line"><span class="cl">        self.capacity = float(capacity)
</span></span><span class="line"><span class="cl">        # 剩余令牌数，初始等于容量上限
</span></span><span class="line"><span class="cl">        self._tokens = capacity
</span></span><span class="line"><span class="cl">        # 填充率
</span></span><span class="line"><span class="cl">        self.fill_rate = float(fill_rate)
</span></span><span class="line"><span class="cl">        self.timestamp = monotonic()
</span></span><span class="line"><span class="cl">        # 数据容器
</span></span><span class="line"><span class="cl">        self.contents = deque()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def add(self, item):
</span></span><span class="line"><span class="cl">        self.contents.append(item)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def pop(self):
</span></span><span class="line"><span class="cl">        # 先进先出
</span></span><span class="line"><span class="cl">        return self.contents.popleft()
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码包括:</p>
<ul>
<li>令牌速率fill_rate</li>
<li>桶的容量上限</li>
<li>一个时间戳</li>
<li>剩余令牌数</li>
<li>算法提供了一个基于双端队列的数据容器，可以对容器进行先进先出操作</li>
</ul>
<p>令牌桶是否可用的判断:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="n">def</span><span class="w"> </span><span class="nf">can_consume</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="s2">&#34;&#34;&#34;Check if one or more tokens can be consumed.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        bool: true if the number of tokens can be consumed
</span></span></span><span class="line"><span class="cl"><span class="s2">            from the bucket.  If they can be consumed, a call will also
</span></span></span><span class="line"><span class="cl"><span class="s2">            consume the requested number of tokens from the bucket.
</span></span></span><span class="line"><span class="cl"><span class="s2">            Calls will only consume `tokens` (the number requested)
</span></span></span><span class="line"><span class="cl"><span class="s2">            or zero tokens -- it will never consume a partial number
</span></span></span><span class="line"><span class="cl"><span class="s2">            of tokens.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">tokens</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">_get_tokens</span><span class="p">():</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 消费n个令牌
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">_tokens</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">tokens</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="no">True</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="no">False</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">def</span><span class="w"> </span><span class="nf">_get_tokens</span><span class="p">(</span><span class="n">self</span><span class="p">):</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_tokens</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 记录当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">monotonic</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 计算已经流失的令牌数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">fill_rate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="kt">timestamp</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 更新容量上限或者剩余令牌和流失数量之和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">_tokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_tokens</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delta</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="kt">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_tokens</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到，算法在进行令牌消费判断的同时，还会对桶的剩余流量进行自校正，很巧妙。</p>
<p>TokenBucket的使用在ConsumerMixin的run方法中。创建了一个速率为1的令牌桶，然后持续的进行消费。如果有令牌则消费消费者上的消息；如果没有令牌则进行休眠</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#ch23-celery/kombu-5.0.0/kombu/mixins.py:240
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ConsumerMixin:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def run(self, _tokens=1, **kwargs):
</span></span><span class="line"><span class="cl">        restart_limit = TokenBucket(1)
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">        # 无限循环
</span></span><span class="line"><span class="cl">        while not self.should_stop:
</span></span><span class="line"><span class="cl">            try:
</span></span><span class="line"><span class="cl">                # 有令牌消费
</span></span><span class="line"><span class="cl">                if restart_limit.can_consume(_tokens):  # pragma: no cover
</span></span><span class="line"><span class="cl">                    for _ in self.consume(limit=None, **kwargs):
</span></span><span class="line"><span class="cl">                        pass
</span></span><span class="line"><span class="cl">                else:
</span></span><span class="line"><span class="cl">                    # 没浪费休眠
</span></span><span class="line"><span class="cl">                    sleep(restart_limit.expected_time(_tokens))
</span></span><span class="line"><span class="cl">            except errors:
</span></span><span class="line"><span class="cl">                ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的休眠时间，是由令牌桶根据期望值计算得来:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def expected_time(self, tokens=1):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Return estimated time of token availability.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Returns:
</span></span><span class="line"><span class="cl">        float: the time in seconds.
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    _tokens = self._get_tokens()
</span></span><span class="line"><span class="cl">    tokens = max(tokens, _tokens)
</span></span><span class="line"><span class="cl">    return (tokens - _tokens) / self.fill_rate
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="round-robin调度算法">Round-Robin调度算法</h2>
<p>Round-Robin调度算法，最常见的大概是在nginx。Round-Robin方式可让nginx将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载，循环往复。在kombu中也提供了几种类似的调度算法:</p>
<ul>
<li>轮询调度</li>
<li>公平调度</li>
</ul>
<p>我们先看Round-Robin方式:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class round_robin_cycle:
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Iterator that cycles between items in round-robin.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;轮询调度算法&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def __init__(self, it=None):
</span></span><span class="line"><span class="cl">        self.items = it if it is not None else []
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def update(self, it):
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;Update items from iterable.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;更新列表&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        self.items[:] = it
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def consume(self, n):
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;Consume n items.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;消费n个元素&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        return self.items[:n]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def rotate(self, last_used):
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;Move most recently used item to end of list.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        &#34;&#34;&#34;旋转:把最后一个元素放到列表某尾&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">        items = self.items
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            items.append(items.pop(items.index(last_used)))
</span></span><span class="line"><span class="cl">        except ValueError:
</span></span><span class="line"><span class="cl">            pass
</span></span><span class="line"><span class="cl">        return last_used
</span></span></code></pre></td></tr></table>
</div>
</div><p>算法实现很简单，就是一个有序队列，可以每次消费前n个有序元素，并且可以将最近使用的元素旋转到队尾。下面是旋转的单元测试:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def test_round_robin_cycle():
</span></span><span class="line"><span class="cl">    it = cycle_by_name(&#39;round_robin&#39;)([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])
</span></span><span class="line"><span class="cl">    assert it.consume(3) == [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
</span></span><span class="line"><span class="cl">    it.rotate(&#39;B&#39;)
</span></span><span class="line"><span class="cl">    assert it.consume(3) == [&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]
</span></span><span class="line"><span class="cl">    it.rotate(&#39;A&#39;)
</span></span><span class="line"><span class="cl">    assert it.consume(3) == [&#39;C&#39;, &#39;B&#39;, &#39;A&#39;]
</span></span><span class="line"><span class="cl">    it.rotate(&#39;A&#39;)
</span></span><span class="line"><span class="cl">    assert it.consume(3) == [&#39;C&#39;, &#39;B&#39;, &#39;A&#39;]
</span></span><span class="line"><span class="cl">    it.rotate(&#39;C&#39;)
</span></span><span class="line"><span class="cl">    assert it.consume(3) == [&#39;B&#39;, &#39;A&#39;, &#39;C&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>还有一种公平循环的调度算法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class FairCycle:
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Cycle between resources.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Consume from a set of resources, where each resource gets
</span></span><span class="line"><span class="cl">    an equal chance to be consumed from.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Arguments:
</span></span><span class="line"><span class="cl">        fun (Callable): Callback to call.
</span></span><span class="line"><span class="cl">        resources (Sequence[Any]): List of resources.
</span></span><span class="line"><span class="cl">        predicate (type): Exception predicate.
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    def __init__(self, fun, resources, predicate=Exception):
</span></span><span class="line"><span class="cl">        self.fun = fun
</span></span><span class="line"><span class="cl">        self.resources = resources
</span></span><span class="line"><span class="cl">        self.predicate = predicate
</span></span><span class="line"><span class="cl">        #  初始位置
</span></span><span class="line"><span class="cl">        self.pos = 0
</span></span></code></pre></td></tr></table>
</div>
</div><p>FairCycle是一种资源之间公平循环的调度算法, 构造函数中:</p>
<ul>
<li>利用资源的函数</li>
<li>多个资源的集合</li>
</ul>
<p>使用的方式是使用get方法传入回调:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def _next(self):
</span></span><span class="line"><span class="cl">    while 1:
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            resource = self.resources[self.pos]
</span></span><span class="line"><span class="cl">            # 位置加1
</span></span><span class="line"><span class="cl">            self.pos += 1
</span></span><span class="line"><span class="cl">            return resource
</span></span><span class="line"><span class="cl">        except IndexError:
</span></span><span class="line"><span class="cl">            # 到尾部后，重置位置
</span></span><span class="line"><span class="cl">            self.pos = 0
</span></span><span class="line"><span class="cl">            if not self.resources:
</span></span><span class="line"><span class="cl">                raise self.predicate()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def get(self, callback, **kwargs):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Get from next resource.&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    # 无限重试
</span></span><span class="line"><span class="cl">    for tried in count(0):  # for infinity
</span></span><span class="line"><span class="cl">        # 获取资源
</span></span><span class="line"><span class="cl">        resource = self._next()
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            # 利用资源
</span></span><span class="line"><span class="cl">            return self.fun(resource, callback, **kwargs)
</span></span><span class="line"><span class="cl">        except self.predicate:
</span></span><span class="line"><span class="cl">            # reraise when retries exchausted.
</span></span><span class="line"><span class="cl">            # 容错上限
</span></span><span class="line"><span class="cl">            if tried &gt;= len(self.resources) - 1:
</span></span><span class="line"><span class="cl">                raise
</span></span></code></pre></td></tr></table>
</div>
</div><p>调度主要体现再获取资源的next函数上，没次获取资源后位置标志进行后移，到尾部后在重置到0，继续下一轮循环。算法还可以对资源进行容错，也就是如果获取到的资源无法正常使用，还可以尝试使用下一个资源进行重试。</p>
<h2 id="lamportclock算法">LamportClock算法</h2>
<p>兰波特时间戳算法(LamportClock)，使用逻辑时间戳作为值的版本以允许跨服务器对值进行排序，是解决分布式系统时间一致的重要算法。</p>
<p>服务器上的系统时间，使用物理的晶体振荡测量，会有不准的情况。我们会经常遇到服务器或者快或者慢的情况，一般使用NTP服务，来和互联网上的某个时间源进行同步。如果本地时间提前了，进行联网校时后，会出现本地时间倒退的问题。而对于两台不同的服务器上，要进行时间统一，就更不能使用系统时间。</p>
<p>兰波特时间戳算法，原理如下:</p>
<ul>
<li>维护一个数字来表示时间戳，并且在每个集群节点都维护一个 Lamport 时钟的实例。</li>
<li>如果事件在节点内发生，时间戳加1</li>
<li>事件要发送到远端，则在消息总带上时间戳</li>
<li>接收到远端的消息，时间戳 = Max(本地时间戳，消息中的时间戳) + 1（进行校正跳跃）</li>
</ul>
<p>这个过程，可以看下面的图示:</p>
<p><img src="https://game404-1251284600.cos.ap-beijing.myqcloud.com/20211107221638.png" alt=""></p>
<p>从图中可以看到下面两点:</p>
<ul>
<li>对于每个节点的事件时间，都是递增有序的，比如A是[4,5,7,10], B节点是[2,3,4,6,7], C节点是[1,5,6,8,9]</li>
<li>时间戳不是全局唯一，不同节点之间会存在序号重复，比如4号消息在A和B节点都存在，5号消息在A和C节点存在</li>
</ul>
<p>了解算法的场景和原理后，我们再来看算法的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class LamportClock:
</span></span><span class="line"><span class="cl">    #: The clocks current value.
</span></span><span class="line"><span class="cl">    value = 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def __init__(self, initial_value=0, Lock=Lock):
</span></span><span class="line"><span class="cl">        self.value = initial_value
</span></span><span class="line"><span class="cl">        self.mutex = Lock()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def adjust(self, other):
</span></span><span class="line"><span class="cl">        with self.mutex:
</span></span><span class="line"><span class="cl">            value = self.value = max(self.value, other) + 1
</span></span><span class="line"><span class="cl">            return value
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def forward(self):
</span></span><span class="line"><span class="cl">        with self.mutex:
</span></span><span class="line"><span class="cl">            self.value += 1
</span></span><span class="line"><span class="cl">            return self.value
</span></span></code></pre></td></tr></table>
</div>
</div><p>算法的实现其实非常简单，就是转发的时候时间戳+1；收到消息后进行校正，这个过程中使用线程锁，保证本地的有序。</p>
<h2 id="laxboundedsemaphore有限信号量算法">LaxBoundedSemaphore有限信号量算法</h2>
<p>前面讲的几种算法，都是基于线程锁实现。使用锁会降低效率，如果在协程中，可以使用无锁的方案，会更高效。kombu的LaxBoundedSemaphore实现，可以作为一种参考。</p>
<p>我们先看使用示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> &gt;&gt;&gt; from future import print_statement as printf
</span></span><span class="line"><span class="cl"># ^ ignore: just fooling stupid pyflakes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x = LaxBoundedSemaphore(2)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x.acquire(printf, &#39;HELLO 1&#39;)
</span></span><span class="line"><span class="cl">HELLO 1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x.acquire(printf, &#39;HELLO 2&#39;)
</span></span><span class="line"><span class="cl">HELLO 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x.acquire(printf, &#39;HELLO 3&#39;)
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x._waiters   # private, do not access directly
</span></span><span class="line"><span class="cl">[print, (&#39;HELLO 3&#39;,)]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x.release()
</span></span><span class="line"><span class="cl">HELLO 3
</span></span></code></pre></td></tr></table>
</div>
</div><p>示例展示了几步:</p>
<ol>
<li>创建一个大小为2的LaxBoundedSemaphore信号量</li>
<li>申请信号，并且执行print函数，可以立即执行</li>
<li>继续申请信号执行print函数，也可以立即执行</li>
<li>再申请信号执行print函数，这时候由于信号超标，函数不会立即执行</li>
<li>手工释放信号量，最后一次申请的print函数自动执行</li>
</ol>
<p>下面是具体的实现，LaxBoundedSemaphore的构造函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class LaxBoundedSemaphore:
</span></span><span class="line"><span class="cl">    def __init__(self, value):
</span></span><span class="line"><span class="cl">        # 信号容量
</span></span><span class="line"><span class="cl">        self.initial_value = self.value = value
</span></span><span class="line"><span class="cl">        # 使用双端队列，FIFO
</span></span><span class="line"><span class="cl">        self._waiting = deque()
</span></span><span class="line"><span class="cl">        self._add_waiter = self._waiting.append
</span></span><span class="line"><span class="cl">        self._pop_waiter = self._waiting.popleft
</span></span></code></pre></td></tr></table>
</div>
</div><p>申请执行回调函数，会进行信号判断，信号充足会执行行回调并消减一次信号量；信号量不足则将函数及参数放入代办的队列:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="n">def</span><span class="w"> </span><span class="nf">acquire</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">partial_args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">partial_kwargs</span><span class="p">):</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="s2">&#34;&#34;&#34;Acquire semaphore.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    This will immediately apply ``callback`` if
</span></span></span><span class="line"><span class="cl"><span class="s2">    the resource is available, otherwise the callback is suspended
</span></span></span><span class="line"><span class="cl"><span class="s2">    until the semaphore is released.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Arguments:
</span></span></span><span class="line"><span class="cl"><span class="s2">        callback (Callable): The callback to apply.
</span></span></span><span class="line"><span class="cl"><span class="s2">        *partial_args (Any): partial arguments to callback.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 容量不够的时候先暂存执行函数，并不更改可用数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="nf">_add_waiter</span><span class="p">((</span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">partial_args</span><span class="p">,</span><span class="w"> </span><span class="n">partial_kwargs</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="no">False</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 可用数量-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1"># 直接执行函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="nf">callback</span><span class="p">(</span><span class="o">*</span><span class="n">partial_args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">partial_kwargs</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="no">True</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用release时候会取出头部的代办函数，并进行执行，此时信号量不增不减。如果代办全部执行完成后，则逐步恢复信号量到默认值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def release(self):
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;Release semaphore.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Note:
</span></span><span class="line"><span class="cl">        If there are any waiters this will apply the first waiter
</span></span><span class="line"><span class="cl">        that is waiting for the resource (FIFO order).
</span></span><span class="line"><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="cl">    try:
</span></span><span class="line"><span class="cl">        waiter, args, kwargs = self._pop_waiter()
</span></span><span class="line"><span class="cl">    except IndexError:
</span></span><span class="line"><span class="cl">        # 无缓存则只增加可用数量
</span></span><span class="line"><span class="cl">        self.value = min(self.value + 1, self.initial_value)
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        # 有缓存则执行第一个缓存，可用数量不变还是小于0
</span></span><span class="line"><span class="cl">        waiter(*args, **kwargs)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="小结">小结</h2>
<p>本篇文章，我们学习了5种实用的业务算法。LRU缓存淘汰算法，可以对缓存中最早的数据进行淘汰。令牌桶限流算法，可以协助进行服务流量限流，较好的保护后端服务，避免突发流量的到时的崩溃。Round-Robin调度算法，可以进行负载的均衡，保障资源的平衡使用。LamportClock时间戳算法，可以在分布式系统中，进行不同服务之间的有序时间戳同步。LaxBoundedSemaphore有限信号量算法，是一种无锁算法，可高效的提供资源使用控制。</p>
<h2 id="小技巧">小技巧</h2>
<p>kombu中提供了一个自动重试算法，可以作为重试算法的模版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kombu-5.0.0/kombu/utils/functional.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def retry_over_time(fun, catch, args=None, kwargs=None, errback=None,
</span></span><span class="line"><span class="cl">                    max_retries=None, interval_start=2, interval_step=2,
</span></span><span class="line"><span class="cl">                    interval_max=30, callback=None, timeout=None):
</span></span><span class="line"><span class="cl">    kwargs = {} if not kwargs else kwargs
</span></span><span class="line"><span class="cl">    args = [] if not args else args
</span></span><span class="line"><span class="cl">    interval_range = fxrange(interval_start,
</span></span><span class="line"><span class="cl">                             interval_max + interval_start,
</span></span><span class="line"><span class="cl">                             interval_step, repeatlast=True)
</span></span><span class="line"><span class="cl">    # 超时时间
</span></span><span class="line"><span class="cl">    end = time() + timeout if timeout else None
</span></span><span class="line"><span class="cl">    for retries in count():
</span></span><span class="line"><span class="cl">        try:
</span></span><span class="line"><span class="cl">            return fun(*args, **kwargs)
</span></span><span class="line"><span class="cl">        except catch as exc:
</span></span><span class="line"><span class="cl">            # 超过次数
</span></span><span class="line"><span class="cl">            if max_retries is not None and retries &gt;= max_retries:
</span></span><span class="line"><span class="cl">                raise
</span></span><span class="line"><span class="cl">            # 超过时间
</span></span><span class="line"><span class="cl">            if end and time() &gt; end:
</span></span><span class="line"><span class="cl">                raise
</span></span><span class="line"><span class="cl">            ...
</span></span><span class="line"><span class="cl">            # 休眠
</span></span><span class="line"><span class="cl">            sleep(1.0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>从模版可以看到重试时候使用次数和超时时间两个维度进行跳出(不可能无限重试):</p>
<ul>
<li>使用count()进行无限循环</li>
<li>使用time()进行超时限定</li>
<li>使用max_retries容错上限次数限定</li>
<li>每次错误后，都休眠一段时间，给被调用方机会，提高下一次成功的概率。</li>
</ul>
<blockquote>
<p>实际上关于休眠时间，也有一些更复杂的算法，比如线性递增之类，这里使用了固定间隔的休眠</p>
</blockquote>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="参考链接">参考链接</h2>
<ul>
<li>缓存淘汰算法 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)</a></li>
<li>令牌桶算法 <a href="https://en.wikipedia.org/wiki/Token_Bucket">https://en.wikipedia.org/wiki/Token_Bucket</a></li>
<li>what-is-token-bucket-and-leaky-bucket-algorithms <a href="https://hansliu.com/posts/2020/11/what-is-token-bucket-and-leaky-bucket-algorithms.html">https://hansliu.com/posts/2020/11/what-is-token-bucket-and-leaky-bucket-algorithms.html</a></li>
<li>波特时间戳算法 <a href="https://en.wikipedia.org/wiki/Lamport_timestamps">https://en.wikipedia.org/wiki/Lamport_timestamps</a></li>
<li>lamport面包店算法简介 <a href="https://segmentfault.com/a/1190000011066299">https://segmentfault.com/a/1190000011066299</a></li>
<li><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html">https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">shawn</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-11-07
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/celery/">celery</a>
          <a href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
          <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/python/celery-5/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Celery 源码解析 - 5</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/service-lang/">
            <span class="next-text nav-default">谁是虽好的语言 ？- 语言选型闲聊（上）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '2021-11-07 23:05:44 \u002b0800 CST',
        title: 'Celery 源码解析 - 4',
        link: decodeURI(location.href),
        desc: '本篇我们继续聊聊kombu这个python实现的消息库中的一些高级算法实现。 Celery是一款非常简单、灵活、可靠的分布式系统，可用于处理大',
        owner: 'game404',
        repo: 'game404.github.io',
        oauth: {
          client_id: '28a86ccaa3184b49dfc4',
          client_secret: '15ab0f7c1445c0afb5e3d7a8995c89f2fd081eb7'
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:studyoo@foxmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/game404" class="iconfont icon-github" title="github"></a>
      <a href="https://juejin.im/user/593f44b8da2f60006736604e" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://game404.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>game404</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-137813525-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
