<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Redis-py 源码阅读 - 游戏不存在</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="shawn" /><meta name="description" content="redis协议规范 redis-py概述 redis-py基础使用 RedisCommand Redis连接 连接池 pipeline LuaScript lock redis协议规范 RESP（Redis Serialization Proto" /><meta name="keywords" content="game, docker, kubernetes, python, go,  microservice" />






<meta name="generator" content="Hugo 0.62.1 with even 4.0.0" />
<meta name="google-site-verification" content="Qzk5S1WaeGv-bmDYA5rCo0HemniTpED_o5PAvmPp-yo" />


<link rel="canonical" href="https://game404.github.io/post/python/redis-py/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Redis-py 源码阅读" />
<meta property="og:description" content="redis协议规范 redis-py概述 redis-py基础使用 RedisCommand Redis连接 连接池 pipeline LuaScript lock redis协议规范 RESP（Redis Serialization Proto" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://game404.github.io/post/python/redis-py/" />
<meta property="article:published_time" content="2021-01-09T21:37:12+08:00" />
<meta property="article:modified_time" content="2021-01-09T21:37:12+08:00" />
<meta itemprop="name" content="Redis-py 源码阅读">
<meta itemprop="description" content="redis协议规范 redis-py概述 redis-py基础使用 RedisCommand Redis连接 连接池 pipeline LuaScript lock redis协议规范 RESP（Redis Serialization Proto">
<meta itemprop="datePublished" content="2021-01-09T21:37:12&#43;08:00" />
<meta itemprop="dateModified" content="2021-01-09T21:37:12&#43;08:00" />
<meta itemprop="wordCount" content="3300">



<meta itemprop="keywords" content="redis,源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis-py 源码阅读"/>
<meta name="twitter:description" content="redis协议规范 redis-py概述 redis-py基础使用 RedisCommand Redis连接 连接池 pipeline LuaScript lock redis协议规范 RESP（Redis Serialization Proto"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">游戏不存在</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">游戏不存在</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Redis-py 源码阅读</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-01-09 </span>
        <div class="post-category">
            <a href="/categories/python/"> python </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#redis">redis协议规范</a></li>
    <li><a href="#redis-py-">Redis-py 源码概述</a></li>
    <li><a href="#redis-py">redis-py基础使用</a>
      <ul>
        <li><a href="#rediscommand">RedisCommand</a></li>
        <li><a href="#redis-1">Redis连接</a></li>
        <li><a href="#heading">连接池</a></li>
      </ul>
    </li>
    <li><a href="#pipeline">pipeline</a></li>
    <li><a href="#luascript">LuaScript</a></li>
    <li><a href="#lock">lock</a></li>
    <li><a href="#todo">TODO</a></li>
    <li><a href="#heading-1">参考链接</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>redis协议规范</li>
<li>redis-py概述</li>
<li>redis-py基础使用
<ul>
<li>RedisCommand</li>
<li>Redis连接</li>
<li>连接池</li>
</ul>
</li>
<li>pipeline</li>
<li>LuaScript</li>
<li>lock</li>
</ul>
<h2 id="redis">redis协议规范</h2>
<p>RESP（Redis Serialization Protocol）是Redis客户端和服务端的通讯协议。数据示例如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+OK\r\n
-Error message\r\n
:1000\r\n
$6\r\nfoobar\r\n
*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n
*3\r\n:1\r\n:2\r\n:3\r\n
</code></pre></td></tr></table>
</div>
</div><p>协议定义了5种类型:</p>
<ol>
<li><code>+</code>前缀表示字符串，后接字符串文本，以<code>\r\n</code>结尾，通常用于命令结果</li>
<li><code>-</code>前缀表示异常信息，后接以空格连接的两个字符串，以<code>\r\n</code>结尾</li>
<li><code>:</code>前缀表示整数，后接整数，以<code>\r\n</code>结尾</li>
<li><code>$</code>前缀表示定长的字符串，后接字符串长度，<code>\r\n</code>和字符串文本，以<code>\r\n</code>结尾</li>
<li><code>*</code>前缀表示数组，后接数组的长度和<code>\r\n</code>，数组的每个元素可以由上面4种类型构成</li>
</ol>
<p>协议还约定了Null等的实现，详情请看参考链接部分。下面示例了 <code>LLEN mylist</code> 的请求和响应</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">C: *2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n

S: :48293\r\n
</code></pre></td></tr></table>
</div>
</div><ul>
<li>客户端发送了 <strong>LLEN mylist</strong>指令，指令序列化成RESP长度为2的数组，2个定长字符串分别是llen和mylist。</li>
<li>服务端响应整数48293，即mylist数据的长度。</li>
</ul>
<p>Request-Response model是redis服务的请求响应模型，可以对比http协议的模式。redis服务端响应客户端的指令，处理后响应回复客户端，可以简单理解为一问一答。当然pipeline，pub/sub和monitor除外。</p>
<h2 id="redis-py-">Redis-py 源码概述</h2>
<p>本文使用的redis-py版本是<code>3.5.3</code>， 文件及包信息是：
名称|描述
&mdash;|&mdash;
client|redis的api
connection|连接，连接池等
exceptions|异常和错误
lock|锁的实现
sentinel|扩展的哨兵连接
utils|工具
_compat|都版本适配包</p>
<p>redis-py未依赖其它的包，代码量虽然不多，6000行左右，但是100%理解还是需要一定的时间和基础。本文从redis-py日常使用出发，也是redis-py的README中内容，介绍这些基础功能在源码中的实现。</p>
<h2 id="redis-py">redis-py基础使用</h2>
<h3 id="rediscommand">RedisCommand</h3>
<p>redis-py的简单使用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; import redis
&gt;&gt;&gt; r = redis.Redis(host=&#39;localhost&#39;, port=6379, db=0)
&gt;&gt;&gt; r.set(&#39;foo&#39;, &#39;bar&#39;)
True
&gt;&gt;&gt; r.get(&#39;foo&#39;)
b&#39;bar&#39;
</code></pre></td></tr></table>
</div>
</div><p>追踪redis-py的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># client.py

class Redis(object)
    
     def __init__(self, host=&#39;localhost&#39;, port=6379,
                 db=0, ..):
        ...
        connection_pool = ConnectionPool(**kwargs)
        self.connection_pool = connection_pool
        ...
                 
    def set(self, name, value, ex=None, px=None, nx=False, xx=False, keepttl=False)
        ...
        return self.execute_command(&#39;SET&#39;, *pieces)
    
    def get(self, name):
        return self.execute_command(&#39;GET&#39;, name)
    
     # COMMAND EXECUTION AND PROTOCOL PARSING
    def execute_command(self, *args, **options):
        &#34;Execute a command and return a parsed response&#34;
        conn = self.connection or pool.get_connection(command_name, **options)
        conn.send_command(*args)
        return self.parse_response(conn, command_name, **options)
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：为了便于理解，示例代码和实际的代码有出入，省去了复杂的逻辑和异常等</p>
</blockquote>
<ul>
<li>redis首先创造了一个到redis服务的连接，</li>
<li>redis包装了redis的所有指令，使用命令模式执行指令。</li>
<li>执行命令就是使用创建的连接发送指令，然后解析和获取响应。这和redis协议上的Request-Response model行为一致。</li>
</ul>
<h3 id="redis-1">Redis连接</h3>
<p>继续查看连接的创建和执行:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># connection.py
class Connection(object)
    
    def __init__(...):
        self.host = host
        self.port = int(port)
        self._sock = connect()
    
    def connect():
        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,
                                      socket.SOCK_STREAM):
            family, socktype, proto, canonname, socket_address = res
            sock = socket.socket(family, socktype, proto)
            ...
            # TCP_NODELAY
            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            # connect
            sock.connect(socket_address)
            ...
            return sock
    
    def pack_command(self, *args):
        command = []
        args = tuple(args[0].encode().split()) + args[1:]
        ...
        buff = SYM_EMPTY.join((SYM_STAR, str(len(args)).encode(), SYM_CRLF))
        for arg in imap(self.encoder.encode, args):
            buff = SYM_EMPTY.join(
                        (buff, SYM_DOLLAR, str(arg_length).encode(), SYM_CRLF))
            output.append(buff)
            output.append(arg)
            ...
        return command
    
    def send_command(self, *args, **kwargs):
        
        command = self.pack_command(args)
            
        if isinstance(command, str):
                command = [command]
        for item in command:
            self._sock.sendall(*args, **kwargs)
        
</code></pre></td></tr></table>
</div>
</div><ul>
<li>connection维持了一个socket连接</li>
<li>收到redis的命令使用pack_command进行RESP的序列化打包</li>
<li>数据包使用socket发送</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># connection.py

class Connection(object)
    
    def __init__(...,parser_class=PythonParser,...);
        self._parser = parser_class(socket_read_size=socket_read_size)

    def read_response(self):
        response = self._parser.read_response()
        return response

class PythonParser(BaseParser):
    &#34;Plain Python parsing class&#34;
    def __init__(self, socket_read_size):
        self.socket_read_size = socket_read_size
        ...
        self._sock = connection._sock
        self._buffer = SocketBuffer(self._sock,
                                    self.socket_read_size,
                                    connection.socket_timeout)
        self.encoder = connection.encoder
    
    def read_response(self):
        raw = self._buffer.readline()

        byte, response = raw[:1], raw[1:]

        # server returned an error
        if byte == b&#39;-&#39;:
            response = nativestr(response)
            ...
        # single value
        elif byte == b&#39;+&#39;:
            pass
        # int value
        elif byte == b&#39;:&#39;:
            response = long(response)
        # bulk response
        elif byte == b&#39;$&#39;:
            length = int(response)
            response = self._buffer.read(length)
        # multi-bulk response
        elif byte == b&#39;*&#39;:
            length = int(response)
            response = [self.read_response() for i in xrange(length)]
        if isinstance(response, bytes):
            response = self.encoder.decode(response)
        return response
    
</code></pre></td></tr></table>
</div>
</div><ul>
<li>connection创建了一个parser用于读取和解析服务响应</li>
<li>默认的PythonParser使用SocketBuffer读取socket数据</li>
<li>read_response实现了RESP协议的解析过程。对于每行数据<code>\r\n</code>，第一个字符是响应类型，剩下的数据内容，如果是multi-bulk还需要循环读取多行。建议对比协议和发送请求进行详细阅读理解。</li>
</ul>
<p>PythonParser是pure-python的实现，如果希望更高效，可以额外安装hiredis，会提供一个基于c的解析器<code>HiredisParser</code>。</p>
<h3 id="heading">连接池</h3>
<p>redis-py使用连接池来提高执行效率，主要的使用方法3个步骤，创建连接池，从连接池中获取有效连接执行命令，完成后释放连接，语句如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># redis.py
connection_pool = ConnectionPool(**kwargs)
pool.get_connection(command_name, **options)

try:
    conn.send_command(*args)
    ...
finally:
    ...
    pool.release(conn)
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>连接池一定要注意释放，可以用try/finally，也可以使用上下文装饰器，这里使用了前者</p>
</blockquote>
<p>连接池的具体实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># connection.py
class ConnectionPool(object):
    
    def __init__(...):
        self._available_connections = []
        self._in_use_connections = set()
    
    def make_connection(self):
        &#34;Create a new connection&#34;
        return self.connection_class(**self.connection_kwargs)
    
    def get_connection(self, command_name, *keys, **options)
        try:
            connection = self._available_connections.pop()
        except IndexError:
            connection = self.make_connection()
        self._in_use_connections.add(connection)
        ...
        connection.connect()
        return connection
        
    def release(self, connection):
        &#34;Releases the connection back to the pool&#34;
        
        try:
            self._in_use_connections.remove(connection)
        except KeyError:
            # Gracefully fail when a connection is returned to this pool
            # that the pool doesn&#39;t actually own
            pass

        self._available_connections.append(connection)
</code></pre></td></tr></table>
</div>
</div><ul>
<li>连接池内部使用可用连接数组和正在使用连接集合管理所有连接</li>
<li>获取连接时候，优先从可用连接数组获取；没有可用连接会创建新的连接</li>
<li>所有获取到的连接会加入正在使用连接, 如果当前连接未连接会先建立连接</li>
<li>连接释放时会从正在使用连接集合中移除，然后加入可用连接数组数组，等待复用</li>
</ul>
<p>到这里，我们基本理顺了一个redis指令执行的流程:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">r = redis.Redis(host=&#39;localhost&#39;, port=6379, db=0)
r.set(&#39;foo&#39;, &#39;bar&#39;)
</code></pre></td></tr></table>
</div>
</div><h2 id="pipeline">pipeline</h2>
<p>redis还支持pipeline管线模式，可以批量发送一些命令，然后获取所有的结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; r = redis.Redis(...)
&gt;&gt;&gt; pipe = r.pipeline()
&gt;&gt;&gt; pipe.set(&#39;foo&#39;, &#39;bar&#39;).sadd(&#39;faz&#39;, &#39;baz&#39;).incr(&#39;auto_number&#39;).execute()
[True, True, 6]
</code></pre></td></tr></table>
</div>
</div><p>pipeline的继承自redis，做了一些扩展</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">class Pipeline(Redis)
    def __init__(...):
        self.command_stack = []
        
    def execute_command(self, *args, **kwargs):
        self.command_stack.append((args, options))
        return self
        
    def execute(self, raise_on_error=True):
        &#34;Execute all the commands in the current pipeline&#34;
        stack = self.command_stack
        
        execute = self._execute_pipeline
        
        execute(conn, stack, raise_on_error)
    
    def _execute_pipeline(self, connection, commands, raise_on_error):
        # build up all commands into a single request to increase network perf
        all_cmds = connection.pack_commands([args for args, _ in commands])
        connection.send_packed_command(all_cmds)

        response = []
        for args, options in commands:
            response.append(
                self.parse_response(connection, args[0], **options))
     
        return response
</code></pre></td></tr></table>
</div>
</div><ul>
<li>pipeline使用一个stack来临时存储批量发送的命令，同时返回自身，这样可以支持链式语法</li>
<li>execute时候才正式发送指令</li>
<li>发送指令后再依次获取服务响应，打包称一个数组统一返回</li>
</ul>
<h2 id="luascript">LuaScript</h2>
<p>redis使用lua脚本来处理事务,使用方法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; r = redis.Redis()
&gt;&gt;&gt; lua = &#34;&#34;&#34;
... local value = redis.call(&#39;GET&#39;, KEYS[1])
... value = tonumber(value)
... return value * ARGV[1]&#34;&#34;&#34;
&gt;&gt;&gt; multiply = r.register_script(lua)
&gt;&gt;&gt; r.set(&#39;foo&#39;, 2)
&gt;&gt;&gt; multiply(keys=[&#39;foo&#39;], args=[5])
10
</code></pre></td></tr></table>
</div>
</div><ul>
<li>lua脚本中定义了KEYS和ARGV两个数组用于接受参数，KEY的第一个值(lua数组从1开始)是key的名称，ARGV的第一个值是倍数</li>
<li>脚本需要进行注册</li>
<li>redis-py中把参数传递给脚本并执行得到结果</li>
</ul>
<p>脚本的实现原理:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># client.py
class Redis(object):

    def register_script(self, script):
        return Script(self, script
        
    def script_load(self, script):
        &#34;Load a Lua ``script`` into the script cache. Returns the SHA.&#34;
        return self.execute_command(&#39;SCRIPT LOAD&#39;, script)
    
    def evalsha(self, sha, numkeys, *keys_and_args):
        return self.execute_command(&#39;EVALSHA&#39;, sha, numkeys, *keys_and_args)

class Script(object):
    &#34;An executable Lua script object returned by ``register_script``&#34;

    def __init__(self, registered_client, script):
        self.registered_client = registered_client
        self.script = script
        # Precalculate and store the SHA1 hex digest of the script.
        ...
        self.sha = hashlib.sha1(script).hexdigest()

    def __call__(self, keys=[], args=[], client=None):
        &#34;Execute the script, passing any required ``args``&#34;
        args = tuple(keys) + tuple(args)
        # make sure the Redis server knows about the script
        ...
        try:
            return client.evalsha(self.sha, len(keys), *args)
        except NoScriptError:
            # Maybe the client is pointed to a differnet server than the client
            # that created this instance?
            # Overwrite the sha just in case there was a discrepancy.
            self.sha = client.script_load(self.script)
            return client.evalsha(self.sha, len(keys), *args
</code></pre></td></tr></table>
</div>
</div><ul>
<li>lua脚本通过 <code>script load</code> 加载到redis服务，并获得一个sha值，sha值可以重用，避免多次加载同一脚本</li>
<li>通过 <code>evalsha</code> 执行脚本</li>
</ul>
<h2 id="lock">lock</h2>
<p>redis-py还提供了一个全局锁的实现, 可以跨进程同步:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">try:
    with r.lock(&#39;my-lock-key&#39;, blocking_timeout=5) as lock:
        # code you want executed only after the lock has been acquired
except LockError:
    # the lock wasn&#39;t acquired
</code></pre></td></tr></table>
</div>
</div><p>下面是其实实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># lock.py
class Lock(object):

    LUA_RELEASE_SCRIPT = &#34;&#34;&#34;
        local token = redis.call(&#39;get&#39;, KEYS[1])
        if not token or token ~= ARGV[1] then
            return 0
        end
        redis.call(&#39;del&#39;, KEYS[1])
        return 1
    &#34;&#34;
    
    def __init__(...):
        ...
        self.redis = redis
        self.name = name
        self.local = threading.local() if self.thread_local else dummy()
        self.local.token = None
        cls = self.__class__
        cls.lua_release = client.register_script(cls.LUA_RELEASE_SCRIPT)
  
    def __enter__(self):
        # force blocking, as otherwise the user would have to check whether
        # the lock was actually acquired or not.
        if self.acquire(blocking=True):
            return self
        raise LockError(&#34;Unable to acquire lock within the time specified&#34;)

    def __exit__(self, exc_type, exc_value, traceback):
        self.release()
        
    def acquire(self, blocking=None, blocking_timeout=None, token=None):
        ...
        token = uuid.uuid1().hex.encode()
        self.redis.set(self.name, token, nx=True, px=timeout)
        ...
        self.local.token = token
        ...
    
    def release(self):
        expected_token = self.local.token
        self.local.token = None
        self.lua_release(keys=[self.name],
                                     args=[expected_token],
                                     client=self.redis)
</code></pre></td></tr></table>
</div>
</div><ul>
<li>LUA_RELEASE_SCRIPT使用lua脚本来处理删除token的事务</li>
<li>lock使用线程变量来存储token值，保证多线程并发可以正常</li>
<li>__enter__和__exit__是装饰器语法，保证可以合法的获取和释放</li>
<li>申请锁的时候获取一个临时的token，然后设置到redis服务中，这个token是有生命周期的，可以超时自动释放。</li>
<li>释放的时候清理线程本地变量和redis服务中的变量</li>
</ul>
<h2 id="todo">TODO</h2>
<p>源码中的 <code>publish/subscibe</code> ， <code>Monitor</code> ,<code>Sentinel</code> 和事务等内容，个人认为并不在主线任务上，留待后续再行介绍。</p>
<h2 id="heading-1">参考链接</h2>
<ul>
<li><a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a></li>
<li><a href="https://github.com/andymccurdy/redis-py">https://github.com/andymccurdy/redis-py</a></li>
<li><a href="https://pypi.org/project/hiredis/#description">https://pypi.org/project/hiredis/#description</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">shawn</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-01-09
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/redis/">redis</a>
          <a href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/python/requests/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">requests 源码阅读</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/python-env-2020/">
            <span class="next-text nav-default">Python虚拟环境指南2020版</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '2021-01-09 21:37:12 \x2b0800 CST',
        title: 'Redis-py 源码阅读',
        link: decodeURI(location.href),
        desc: 'redis协议规范 redis-py概述 redis-py基础使用 RedisCommand Redis连接 连接池 pipeline LuaScript lock redis协议规范 RESP（Redis Serialization Proto',
        owner: 'game404',
        repo: 'game404.github.io',
        oauth: {
          client_id: '28a86ccaa3184b49dfc4',
          client_secret: '15ab0f7c1445c0afb5e3d7a8995c89f2fd081eb7'
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:studyoo@foxmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/game404" class="iconfont icon-github" title="github"></a>
      <a href="https://juejin.im/user/593f44b8da2f60006736604e" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://game404.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">game404</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-137813525-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
